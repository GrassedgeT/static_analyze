{
  "edn": "# EDN HWIP Technical Specification\n\n[`edn`](https://reports.opentitan.org/hw/ip/edn/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/edn/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/edn/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/edn/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/edn/code.svg)\n\n# Overview\n\nThis document specifies EDN hardware IP functionality.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\n\n## Features\n\nThe Entropy Distribution Network (EDN) block provides both hardware and software interfaces to the [CSRNG IP](../csrng/README.md) module.\nA primary objective of the EDN block is to provide a simpler hardware interface for the peripheral blocks to use, in which case they do not have to directly interface with the CSRNG module.\n- The EDN block provides a set of registers for firmware to manage a CSRNG application interface port.\n- There are eight request/acknowledge hardware interfaces.\n- Each hardware interface supports a fixed bus width of 32 bits.\n- The EDN block has an \"auto request mode\" where `generate` and `reseed` CSRNG application commands can be programmed to be done continuously in hardware.\n- There is also a \"boot-time request mode\",  where a single TL-UL configuration write will trigger a proper CSRNG application command sequence to fetch the pre-FIPS entropy for tasks immediately at boot-time or after reset.\n- There are two interrupts that are supported:\n  - CSRNG application command has completed.\n  - An internal FIFO error has occurred.\n- There are two alerts that are implemented in this revision:\n  - A fatal alert to report common security fatal errors and EDN specific fatal errors. A list of fatal errors are listed in the [`ERR_CODE`](data/edn.hjson#err_code) register.\n  - A recoverable alert to report recoverable error. A list of fatal errors are listed in the [`RECOV_ALERT_STS`](data/edn.hjson#recov_alert_sts) register.\n\n## Description\n\nThis IP block acts as a gasket between peripheral hardware blocks and the CSRNG block.\nOne function this IP block performs is to translate data transfer size.\nFor example, CSRNG will return 128 bits on the `genbits` bus.\nA peripheral block will connect with a 32-bit data bus.\nThe EDN block will move the first 32 bits from the returned `genbits` bus, and hold on to the remaining data until another request asks for more data.\nFurthermore, if data is not consumed immediately, the interface to the CSRNG will indicate back pressure to the CSRNG block.\nEach of the hardware interfaces can request data such that any `genbits` bus return can supply any requesting peripheral block.\n\nAt most one hardware peripheral block can connect to each EDN peripheral port.\nHardware peripherals request more data from the EDN by asserting the `req` signal.\nWhen random values are available, the EDN transmits them on the `bus` and asserts an `ack` signal to signify the arrival of fresh values.\n\nApplication interface commands to the CSRNG block can be generated by either firmware or hardware.\n\nFirmware can issue CSRNG commands on behalf of hardware peripherals, by writing the commands to the [`SW_CMD_REQ`](data/edn.hjson#sw_cmd_req) register.\nThe command status response is captured in the [`SW_CMD_STS`](data/edn.hjson#sw_cmd_sts) register.\nEven when CRSNG `generate` commands are issued by firmware, all random values are distributed to the hardware peripherals.\n\nIf firmware applications require random values for their *own* use, they must issue the commands directly to the CSRNG, which maintains a dedicated CSRNG instance for firmware that is accessible through TL-UL.\n\nThere are two modes for EDN hardware to generate CSRNG commands.\nOne is the \"auto request mode\", where two FIFOs are used to send commands.\nThe general operation of this mode is that the CSRNG instance is set up by firmware, then the FIFOs are preloaded with commands.\nOne FIFO can be programmed to send `generate` commands.\nThe other FIFO can be programmed to send `reseed` commands.\nThe [`MAX_NUM_REQS_BETWEEN_RESEEDS`](data/edn.hjson#max_num_reqs_between_reseeds) register sets the number of `generate` commands allowed between `reseed` commands.\nOnce this is done, the EDN block can request data from the CSRNG once firmware has instantiated the associated instance through the EDN command forwarding interface.\nWhen in this mode, the EDN emits `generate` commands from the first FIFO to get more data.\nOnce the [`MAX_NUM_REQS_BETWEEN_RESEEDS`](data/edn.hjson#max_num_reqs_between_reseeds) timer expires, the EDN block emits a `reseed` command from the second FIFO.\nThe process of sending these two commands will repeat forever until the `EDN_ENABLE` field is cleared, the `AUTO_REQ_MODE` field is cleared, or the EDN is reset.\n\nAny of the command FIFOs can be reset by asserting the `CMD_FIFO_RST` field in the [`CTRL`](data/edn.hjson#ctrl) register.\n\nThe other mode is \"boot-time request mode\", where only the hardware generates CSRNG application interface commands.\nIn this mode a single `instantiate` command is sent, followed by a stream of `generate` commands.\nThis sequence fetches the initial random values needed for the system to boot.\nUse of boot-time request mode, though simpler in operation, is only for applications which do not require FIPS-approved random values.\nPlease see the [entropy_src IP documentation](../entropy_src/README.md) for more information on trade-offs when creating CSRNG seeds before the completion of the FIPS-required health checks.\nIn boot-time request mode the generate commands continue until `EDN_ENABLE` field is cleared (set to false), the `BOOT_REQ_MODE` field is cleared, or the EDN is reset.\nNote that when the `EDN_ENABLE` field is cleared or the `BOOT_REQ_MODE` field is cleared, an `uninstantiate` command needs to be sent by firmware to destroy the instance in csrng.\nNote that the EDNs and CSRNG should always be reset together to ensure proper instantiation or uninstantiation of state variables.\n\n### Security\n\nAll module assets and countermeasures performed by hardware are listed in the hjson countermeasures section.\nLabels for each instance of asset and countermeasure are located throughout the RTL source code.\n\nThe receiving FIFO for genbits from CSRNG will have a hardware check on the output bus.\nThis is done to make sure repeated values are not occurring.\nOnly 64 bits (out of 128 bits) are checked, since this is statistically significant, and more checking would cost more silicon.\nIt is expected that an endpoint requiring high-quality entropy will do an additional consistency hardware check on the 32 bit data bus.\nAdditionally the FIPS signal on the endpoint bus should also be checked for high-quality entropy consumers.\nBoot request mode is an example where the FIPS signal will not be ever be set, and consuming endpoint of low-quality entropy do not need to check this signal.\n\n\n## Example Topology\nIn general, the OpenTitan random number subsystem consists of one `entropy_src`, one CSRNG, and one or more EDNs.\nThe `entropy_src` only supports one connection to a CSRNG, but the CSRNG has multiple application interface ports for connecting to EDN's or other hardware blocks.\nIn the example below, two EDN modules are used to distribute `genbits` from the CSRNG to peripheral modules.\n(Note that this is just an example; consult the specification of a specific top-level design for the specific configuration used there.)\n\n![EDN Example Topology Diagram](./doc/edn_top_diag.svg)\n",
  "prim_xilinx_ultrascale": "No README available.",
  "usbdev": "# USB 2.0 Full-Speed Device HWIP Technical Specification\n\n[`usbdev`](https://reports.opentitan.org/hw/ip/usbdev/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/usbdev/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/usbdev/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/usbdev/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/usbdev/code.svg)\n\n# Overview\n\nThis document specifies the USB device hardware IP functionality.\nThis IP block implements a Full-Speed device according to the [USB 2.0 specification.](https://www.usb.org/document-library/usb-20-specification)\nIt is attached to the chip interconnect bus as a peripheral module and conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\n\n\n## Features\n\nThe IP block implements the following features:\n\n- USB 2.0 Full-Speed (12 Mbps) Device interface\n- 2 kB interface buffer\n- Up to 12 endpoints (including required Endpoint 0), configurable using a compile-time Verilog parameter\n- Support for USB packet sizes up to 64 bytes\n- Support SETUP, IN and OUT transactions\n- Support for Bulk, Control, Interrupt and Isochronous endpoints and transactions\n- Streaming possible through software\n- Interrupts for packet reception and transmission\n- Flippable D+/D- pins, configurable via software, useful if it helps routing the PCB or if D+/D- are mapped to SBU1/SBU2 pins of USB-C\n\nIsochronous transfers larger than 64 bytes are currently not supported.\nThis feature might be added in a later version of this IP.\n\n\n## Description\n\nThe USB device module is a simple software-driven generic USB device interface for Full-Speed USB 2.0 operation.\nThe IP includes the physical layer interface, the low level USB protocol and a packet buffer interface to the software.\nThe physical layer interface features multiple transmit and receive paths to allow interfacing with a variety of USB PHYs or regular 3.3V IO pads for FPGA prototyping.\n\n\n## Compatibility\n\nThe USB device programming interface is not based on any existing interface.\n",
  "hmac": "# HMAC HWIP Technical Specification\n\n[`hmac`](https://reports.opentitan.org/hw/ip/hmac/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/hmac/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/hmac/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/hmac/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/hmac/code.svg)\n\n# Overview\n\nThis document specifies HMAC hardware IP functionality. This module conforms to\nthe [OpenTitan guideline for peripheral device functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader OpenTitan top level system.\n\n\n## Features\n\n- Two modes: SHA-2 | HMAC based on SHA-2\n- Multiple digest sizes supported (for both modes): SHA-2 256/384/512 hashing algorithm\n- Configurable key length 128/256/384/512/1024-bit secret key for HMAC mode\n- Support for context switching (via saving and restoring) across multiple message streams\n- 32 x 32-bit message FIFO buffer\n\n## Description\n\n[sha256-spec]: https://csrc.nist.gov/publications/detail/fips/180/4/final\n\nThe HMAC module is a [SHA-2][sha256-spec] hash-based authentication code generator to check the integrity of an incoming message and a signature signed with the same secret key.\nIt supports SHA-2 256/384/512 and 128/256/384/512/1024-bit keys in HMAC mode, so long as the key length does not exceed the block size of the configured SHA-2 digest size, i.e., 1024-bit keys are not supported for SHA-2 256 where the block size is 512-bit.\nIt generates a different authentication code with the same message if the secret key is different.\n\nThis HMAC implementation is not hardened against side channel or fault injection attacks.\nIt is meant purely for hashing acceleration.\nIf hardened MAC operations are required, users should use either [KMAC](../kmac/README.md) or a software implementation.\n\nThe secret key is written in [`KEY_0-KEY_31`](doc/registers.md#key), and the key length relevant to the HMAC operation is configured in [`CFG.key_length`](doc/registers.md#cfg--key_length).\nFor example, to use a 256-bit secret key, [`CFG.key_length`](doc/registers.md#cfg--key_length) needs to be configured (as per register documentation) and then only the relevant secret key registers, only [`KEY_0-KEY_7`](doc/registers.md#key) in this case, are consumed for the HMAC operation.\nThe digest size required is configured in [`CFG.digest_size`](doc/registers.md#cfg--digest_size).\nThe message to authenticate is written to [`MSG_FIFO`](doc/registers.md#msg_fifo) and the HMAC generates a 256/384/512-bit digest value (depending on the digest size configuration provided) which can be read from [`DIGEST_0-DIGEST_7`](doc/registers.md#digest) for SHA-2 256, or from [`DIGEST_0-DIGEST_12`](doc/registers.md#digest) for SHA-2 384, or from [`DIGEST_0-DIGEST_15`](doc/registers.md#digest) for SHA-2 512.\nThe `hmac_done` interrupt is raised to report to software that the final digest is available.\n\nThis module allows software to save and restore the hashing context so that different message streams can be interleaved; please check the [Programmer's Guide](doc/programmers_guide.md#saving-and-restoring-the-context) for more information.\n\nThe HMAC IP can run in SHA-2 only mode, whose purpose is to check the correctness of the received message.\nThe same digest registers above are used to hold the final hash result.\nSHA-2 mode does not use the given secret key.\nIt generates the same result with the same message every time.\n\nThe software does not need to provide the message length. The HMAC IP\nwill calculate the length of the message received between **1** being written to\n[`CMD.hash_start`](doc/registers.md#cmd) and **1** being written to [`CMD.hash_process`](doc/registers.md#cmd).\n\nThis version does not have many defense mechanisms but is able to wipe internal variables such as the secret key, intermediate hash results, digest and the internal message scheduling array.\nIt does not wipe the message FIFO, which SW writes the message to (but cannot read from).\nThe software can wipe the internal variables and secret key by writing a 32-bit random value into [`WIPE_SECRET`](doc/registers.md#wipe_secret) register.\nThe internal variables and secret key will be reset to the written value.\nFor SHA-2 384/512 modes that operate on 64-bit words, the 32-bit random value is replicated and concatenated to create the 64-bit value.\nThis version of the HMAC does not have an internal pseudo-random number generator to derive the random number from the written seed number.\n\nA later update may provide an interface for external hardware IPs, such as a key manager, to update the secret key.\nIt will also have the ability to send the digest directly to a shared internal bus.\n",
  "csrng": "# CSRNG HWIP Technical Specification\n\n[`csrng`](https://reports.opentitan.org/hw/ip/csrng/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/csrng/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/csrng/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/csrng/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/csrng/code.svg)\n\n# Overview\n\nThis document specifies the Cryptographically Secure Random Number Generator (CSRNG) hardware IP functionality.\nDue to the importance of secure random number generation (RNG), it is a topic which is extensively covered in security standards.\nThis IP targets compliance with both [BSI's AIS31 recommendations for Common Criteria (CC)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_31_Functionality_classes_for_random_number_generators_e.pdf), as well as [NIST's SP 800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) and [NIST's SP 800-90C (Second Draft)](https://csrc.nist.gov/CSRC/media/Publications/sp/800-90c/draft/documents/sp800_90c_second_draft.pdf), both of which are referenced in [FIPS 140-3](https://csrc.nist.gov/publications/detail/fips/140/3/final).\nThe CSRNG IP supports both of these standards for both deterministic (DRNG) and true random number generation (TRNG).\nIn NIST terms, it works with the [Entropy Source IP](../entropy_src/README.md) to satisfy the requirements as a deterministic random bit generator (DRBG) or non-deterministic random bit generator (NRBG).\nIn AIS31 language, this same implementation can be used to satisfy either the DRG.3 requirements for deterministic generation, or the PTG.3 requirements for cryptographically processed physical generation.\n\nIn this document the terms \"DRNG\" and \"TRNG\" are used most generally to refer to deterministic or true random number generation functionalities implemented to this specification.\nHowever, the terms \"DRBG\" or \"NRBG\" are specifically used when respectively referring to SP 800-90A or SP 800-90C requirements.\nMeanwhile, when addressing requirements which originate from AIS31 we refer to the specific DRG.3 or PTG.3 classes of RNGs.\n\nThis IP block is attached to the chip interconnect bus as a peripheral module conforming to the [comportability definition and specification](../../../doc/contributing/hw/comportability/README.md), but also has direct hardware links to other IPs for secure and software-inaccessible transmission of random numbers.\nThe bus connections to peripheral modules are done using the CSRNG application interface.\nThis interface allows peripherals to manage CSRNG instances, and request the CSRNG module to return obfuscated entropy.\n\n## Features\n- Provides support for both deterministic (DRNG) and true random number generation (TRNG), when combined with a secure entropy source (i.e. one constructed and implemented in compliance with SP 800-90A,B,C and AIS31).\n  The TRNG mode is provided directly by the entropy source.\n- Compliant with NIST and BSI recommendations for random number generation.\n- Hardware peripherals and software applications issue commands to dedicated RNG instances through a common application interface.\n- In deterministic mode, meets the requirements given in AIS31 for a DRG.3 class deterministic random number generator (DRNG) meaning it provides Forward Secrecy and Enhanced Backward Secrecy.\n- Utilizes the CTR_DRBG construction specified in NIST SP 800-90A, qualifying it as a NIST-approved deterministic random bit generator (DRBG).\n    - Operates at 256 bit security strength.\n- Support for multiple separate CSRNG instances per IP block.\n    - Each instance has its own internal state, control, reseed counters and IO pins.\n    - The number of CSRNG instances is set via a module parameter.\n- Software access to a dedicated CSRNG instance.\n    - One instance, Instance N-1, is always accessible from the bus through device registers,\n    - All other instances route to other hardware peripherals (e.g. the key manager, obfuscation engines, etc.) and in normal operation these other instances are inaccessible from software.\n    - The IP may be configured to support \"debug mode\" wherein all instances can be accessed by software.\n      For security reasons this mode may be permanently disabled using one-time programmable (OTP) memory.\n- The IP interfaces with external entropy sources to obtain any required non-deterministic seed material (entropy) and nonces.\n    - Requires an external entropy source which is compliant with NIST SP 800-90B, and which also satisfies the requirements for a PTG.2 class physical non-deterministic random number generator as defined in AIS31.\n    - Dedicated hardware interface with external entropy source satisfies requirements for `get_entropy_input()` interface as defined in SP 800-90A.\n    - This block does not use a derivation function and requires full entropy from the entropy source.\n- Also supports the optional use of personalization strings or other application inputs (e.g. OTP memory values) during instantiation.\n- Assuming a continuously-live entropy source, each instance can also optionally be used as a non-deterministic TRNG (true random number generator, also called a non-deterministic random bit generator or NRBG in SP 800-90C).\n    - In this mode, an instance also meets the requirements laid out for a PTG.3 class RNG, the strongest class laid out in AIS31.\n    - Implementation follows the NRBG \"Oversampling Construction\" approved by SP 800-90C, to meet both [Common Criteria (CC, ISO/IEC 15408)](https://www.iso.org/standard/50341.html) and FIPS TRNG constructions.\n- In addition to the approved DRNG mode, any instance can also operate in \"Fully Deterministic mode\", meaning the seed depends entirely on application inputs or personalization strings.\n    - This provides an approved means of seed construction in FIPS 140-2 as described in the [FIPS 140-2 Implementation Guidance](https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf), section 7.14, resolution point 2(a).\n\n## Description\n\nThough the recommendations in AIS31 are based around broad functional requirements, the recommendations in SP 800-90 are very prescriptive in nature, outlining the exact constructs needed for approval.\nThus the interface and implementation are largely driven by these explicit constructs, particularly the CTR_DRBG construct.\n\nThe CSRNG IP consists of four main components:\n1. An AES primitive\n2. The CTR_DRBG state-machine (`ctr_drbg_fsm`) which drives the AES primitive, performing the various encryption sequences prescribed for approved DRBGs in SP 800-90A.\nThese include:\n\n    1. **The Instantiation Routine:**\n       Takes external entropy and/or additional data (personalization string) to instantiate the DRNG instance.\n    1. **The Reseed Routine:**\n       Combines the previous seed material with external entropy and/or additional data (personalization string) to generate a new seed.\n    1. **The Generate Routine:**\n       Generates up to 4095 * 128 random bits, which is less than the maximum 2<sup>19</sup> bits allowed by NIST (referenced to as <tt>max_number_of_bits_per_request</tt>).\n    1. **The Update Routine:**\n       Updates the internal state of the DRNG instance.\n       It is automatically executed during instantiate, reseed and generate calls, but can also be explicitly called to combine additional data with the internal state of the DRNG instance.\n3. State vectors for each DRNG instance.\n4. Interface logic and access control for each instance.\n\n## Note on the term \"Entropy\"\n\nEvery DRNG requires some initial seed material, and the requirements for the generation of that seed material varies greatly between standards, and potentially between Common Criteria security targets.\nIn all standards considered, DRNGs require some \"entropy\" from an external source to create the initial seed.\nHowever, the rules for obtaining said entropy differ.\nFurthermore the required delivery mechanisms differ.\nFor this reason we must make a clear distinction between \"Physical\" (or \"Live\" or \"True\") entropy and \"Factory Entropy\".\nThis distinction is most important when considering the creation of IP which is both compatible with both the relatively new SP 800-90 recommendations, as well as the well-established FIPS 140-2 guidelines.\n\n- Physical entropy is the only type of \"entropy\" described in SP 800-90.\nThe means of generation is described in [SP 800-90B](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90B.pdf).\nOne statistical test requirement is that physical entropy must be unique between reboot cycles, ruling out sources such as one-time programmable (OTP) memories.\nIn SP 800-90A, the delivery mechanism must come through a dedicated interface and \"not be provided by the consuming application\".\n\n- Factory entropy is a type of entropy described in the [FIPS 140-2 implementation guidance (IG)](https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/fips140-2/fips1402ig.pdf) section 7.14, resolution point 2(a).\nIt can be stored in a persistent memory, programmed at the factory.\nIn some use cases, the consuming application needs to explicitly load this entropy itself and process it to establish the expected seed.\n\nThis document aims to make the distinction between physical entropy and factory entropy wherever possible.\nHowever, if used unqualified, the term \"entropy\" should be understood to refer to physical entropy strings which are obtained in accordance with SP 800-90C.\nThat is either physical entropy, or the output of a DRNG which itself has been seeded (and possibly reseeded) with physical entropy.\nIn AIS31 terms, \"entropy strings\" (when used in this document without a qualifier) should be understood to come from either a PTG.2 or PTG.3 class RNG.\n\n### Security\n\nAll module assets and countermeasures performed by hardware are listed in the hjson countermeasures section.\nLabels for each instance of asset and countermeasure are located throughout the RTL source code.\n\nThe bus integrity checking for genbits is different for software and hardware.\nOnly the application interface software port will have a hardware check on the genbits data bus.\nThis is done to make sure repeated values are not occurring.\nOnly 64 bits (out of 128 bits) are checked, since this is statistically significant, and more checking would cost more silicon.\nThe application interface hardware port will not have this check.\nIt is expected that the requesting block (EDN) will do an additional hardware check on the genbits data bus.\n\n## Compatibility\nThis block is compatible with NIST's SP 800-90A and BSI's AIS31 recommendations for Common Criteria.\n",
  "trial1": "No README available.",
  "rv_core_ibex": "# Ibex RISC-V Core Wrapper Technical Specification\n\n[`rv_core_ibex`](https://ibex.reports.lowrisc.org/opentitan/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/ibex/opentitan/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/ibex/opentitan/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/ibex/opentitan/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/ibex/opentitan/code.svg)\n\n# Overview\n\nThis document specifies Ibex CPU core wrapper functionality.\n\n## Features\n\n* Instantiation of a [Ibex RV32 CPU Core](https://github.com/lowRISC/ibex).\n* TileLink Uncached Light (TL-UL) host interfaces for the instruction and data ports.\n* Simple address translation.\n* NMI support for security alert events for watchdog bark.\n* General error status collection and alert generation.\n* Crash dump collection for software debug.\n\n## Description\n\nThe Ibex RISC-V Core Wrapper instantiates an [Ibex RV32 CPU Core](https://github.com/lowRISC/ibex), and wraps its data and instruction memory interfaces to TileLink Uncached Light (TL-UL).\nAll configuration parameters of Ibex are passed through.\nThe pipelining of the bus adapters is configurable.\n\n## Compatibility\n\nIbex is a compliant RV32 RISC-V CPU core, as [documented in the Ibex documentation](https://ibex-core.readthedocs.io/en/latest/01_overview/compliance.html).\n\nThe TL-UL bus interfaces exposed by this wrapper block are compliant to the [TileLink Uncached Lite Specification version 1.7.1](https://sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf).\n",
  "aon_timer": "# AON Timer Technical Specification\n\n[`aon_timer`](https://reports.opentitan.org/hw/ip/aon_timer/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/aon_timer/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aon_timer/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aon_timer/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aon_timer/code.svg)\n\n# Overview\n\nThis document specifies the Always-On (\"AON\") Timer IP functionality.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for an overview of how it is integrated into the top level system.\n\n## Features\n\n- Two 32-bit upcounting timers: one timer functions as a wakeup timer, one as a watchdog timer\n- The watchdog timer has two thresholds: bark (generates an interrupt) and bite (resets core)\n- There is 12 bit pre-scaler for the wakeup timer to enable very long timeouts\n\n## Description\n\n### AON Wakeup timer\n\nThe always-on wakeup timer operation is straightforward.\nA count starts at 0 and slowly ticks upwards (one tick every `N + 1` clock cycles, where `N` is the pre-scaler value).\nWhen it reaches / exceeds the wake threshold, a level wakeup signal is sent to the power manager and a level IRQ is sent to the processor.\nThis wakeup signal stays high until it is explicitly acknowledged by software.\nTo clear the wakeup write 0 to the [`WKUP_CAUSE`](data/aon_timer.hjson#wkup_cause) register.\nTo clear the interrupt write 1 to [`INTR_STATE.wkup_timer_expired`](data/aon_timer.hjson#intr_state).\nNote that if [`WKUP_COUNT`](data/aon_timer.hjson#wkup_count) is not zeroed and remains at or above the wake threshold and the wakeup timer isn't disabled, the wakeup and interrupt will trigger again at the next clock tick.\nThe wakeup timer can be used like a real-time clock for long periods in a low-power mode (though it does not give any guarantees of time-accuracy). **TODO: specify accuracy**\n\n### AON Watchdog timer\n\nThe always-on watchdog timer behaves similarly to the wakeup timer.\nIt has an independent count starting at 0 which slowly ticks upwards.\nWhen the first threshold is met or exceeded, a level wakeup signal (if enabled) is sent to the power manager.\nSimultaneously, a level IRQ signal is also generated to the processor.\n\nIf the system is in a low power state, the wakeup signal asks the power manager to wake the system so that the IRQ can be serviced.\nIf the system is not in a low power mode, the IRQ is immediately serviced.\nBoth the wakeup and the IRQ signals remain asserted until system reset or explicit acknowledgement by software.\nThis first threshold is known as the watchdog bark.\n\nAn extra interrupt output is available to connect the watchdog bark output to a non-maskable interrupt pin if required.\n\nWhen the second threshold is met (this is known as the watchdog bite), a reset request is sent to the power manager which will trigger a system reset.\nThis is independent of the IRQ sent as part of the watchdog bark.\nThe system reset also resets the always-on timer, so software is not required to directly acknowledge anything after a watchdog reset.\n\nTo prevent the watchdog bark or bite, software is expected to periodically reset the count when operating normally.\nThis is referred to as petting the watchdog, and is achieved by resetting the count to zero.\n\nSince this timer functions as a watchdog, it has three additional functions not present in the always-on wakeup timer:\n* Watchdog configuration lock\n* Watchdog pause in sleep\n* Watchdog pause during system escalation\n\nUnlike the wakeup timer, the watchdog timer configuration can be locked by firmware until the next system reset.\nThis allows the option of preventing firmware from accidentally or maliciously disabling the watchdog.\n\nThe \"pause in sleep\" option controls whether the watchdog timer continues to count in low-power modes.\nThis allows configurations where the watchdog timer can remain programmed and locked while the device is put to sleep for relatively long periods, controlled by the wakeup timer.\nWithout this feature, the watchdog timer might wake up the core prematurely by triggering a watchdog bark.\n\nThe \"pause during escalation\" feature ensures that watchdog bites and barks do not interfere with system escalation behavior.\nIf during escalation software configures the system to hang instead of reset, the watchdog bite cannot supersede that decision.\n",
  "pwm": "# PWM HWIP Technical Specification\n\n[`pwm`](https://reports.opentitan.org/hw/ip/pwm/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/pwm/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pwm/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pwm/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pwm/code.svg)\n\n# Overview\n\nThis document specifies PWM hardware IP (HWIP) functionality.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top-level system.\n\n## Features\n\n- Pulse-width modulated (PWM) with adjustable duty cycle\n- Suitable for general-purpose use, but primarily designed for control of tri-color LEDs\n- Parameterizable number of output channels\n- Separate clock domains for TL-UL I/O vs. core operations\n   - PWM operation can continue in low-power state.\n- Independent control of duty cycle, phase, and polarity for all channels\n- Programmable resolution (1 to 16 bits) in adjusting the output duty cycle and phase\n- All output channels are driven at the same pulse frequency, which is selected by a 27-bit clock divider\n- Hardware-controlled blink feature\n   - Blinking channel toggles between two separably programmable duty cycles\n   - Blink timing is independently programmable for each channel\n- \"Heartbeat\" blink mode\n   - Output duty cycle linearly increments and decrements between two programmable values\n   - Step size and step frequency are independently programmable for each channel\n- Channels can be configured to blink synchronously or independently\n- All duty cycle settings are independently programmable\n\n## Description\n\nThe PWM IP is primarily designed to drive a parameterizable number of pulse-width modulated outputs with periodic pulses each with a programmable frequency, phase, and duty cycle (i.e. the ratio between the pulse duration and the overall period between pulses.)\n\nThe phase and duty cycle of each output channel can then be controlled with programmable resolution, from 1-bit (half-cycle resolution) to 16-bit (in which case pulse width and timing can be controlled to one part in 2<sup>16</sup> relative to the pulse period)\n\nBy default the output pulses are active-high, however the polarity can also be inverted by firmware.\n\nFor operation in low-power modes, the PWM IP core runs from a second clock, independent of the TL-UL bus clock.\n\nAll outputs are pulsed at a common clock frequency, which can be controlled relative to the PWM core clock by a 27-bit clock divider.\nThe overall pulse frequency depends on this clock-divider and the phase-resolution.\n\nThe primary application is to control tri-color LEDs.\nThe intensity of each LED channel can be adjusted by varying the duty cycle of the PWM outputs.\nThe IP provides capabilities for driving a trio of RGB LEDs at any 24-bit RGB-color combination.\nIt principle, this requires a minimum of 8-bits of programmable duty cycle resolution for each output.\nHowever, the proper mapping of LED duty-cycles to perceived colors will depend on many factors, such as non-linear response function of the chosen LED and the choice of current driver.\nThus the IP provides up to 16-bits of duty cycle resolution, to allow for fine-grain duty cycle control.\nThe resolution can be also reduced down as low as 1-bit, to allow for more frequent pulses when connected to a low-frequency, low-power bus.\n\nThis IP only controls the *timing* of the PWM drive signal.\nThe drive *current* must be managed by the system designer by including the appropriate off-chip circuitry.\nFor instance, in the LED-drive use-case, various off-chip solutions exist for controlling the current, such as selection of an appropriate series resistance, or the use of an external fixed-current LED drive IC.\nSome limited possibilities for current control may also exist in a top-level ASIC design.\nHowever, such configuration options are outside the scope of this document.\n\nIn order to support a variety of drive configurations, the polarity of each channel may be inverted.\n\nThe PWM IP is also suitable for driving other outputs, such as servo motors.\nIn some applications, the user may wish to stagger outputs to limit the overall magnitude of current spikes in the complete system.\nThus each output also has a phase control register, with up to 16-bit resolution.\nIn security applications it is the system-designer's responsibility to ensure that improper configuration of the phase control registers does not pose a security risk to the overall system (due to, for instance, a denial of service attack through the PWM configuration).\n\nThe PWM IP provides a hardware-controlled blink feature, which can periodically toggle the output between two states with separate duty cycles.\nThis feature can be used to significantly reduce the output duty cycle (blink-off), or, in the case of tri-color LEDs, toggle the apparent LED color between the two settings.\nThis feature is enabled on a per-channel basis, and for each blinking channel, the blink period and blink duty cycle are programmed in terms of the number of pulses generated in either state.\n\nAs a variant of the blink feature, the output duty cycle can also be programmed to linearly increase and decrease in time.\nIn this \"heartbeat\" mode, the duty cycle increments by a programmable amount after a programmable number of pulses, starting at some firmware-selected initial duty cycle.\nOnce the internal duty cycle reaches the target value, the internal duty cycle begins to decrement until it returns to the initial value, at which point the cycle repeats until heartbeat mode is disabled.\n",
  "pinmux": "# Pinmux Technical Specification\n\n\n# Overview\n\nThis document specifies the functionality of the pin multiplexer (`pinmux`) peripheral.\nThis module conforms to the [OpenTitan guideline for peripheral device functionality](../../../doc/contributing/hw/comportability/README.md).\nSee that document for integration overview within the broader OpenTitan top level system.\nThe module provides a mechanism to reconfigure the peripheral-to-pin mapping at runtime, which greatly enhances the system flexibility.\nIn addition to that, the `pinmux` also allows the user to control pad attributes (such as pull-up, pull-down, open-drain, drive-strength, keeper and inversion), and it contains features that facilitate low-power modes of the system.\nFor example, the sleep behavior of each pad can be programmed individually, and the module contains additional pattern detectors that can listen on any IO and wake up the system if a specific pattern has been detected.\n\n## Features\n\n- Configurable number of chip bidirectional IOs\n\n- Configurable number of peripheral inputs and outputs\n\n- Programmable mapping from peripheral outputs (and output enables) to top-level outputs (and output enables)\n\n- Programmable mapping from top-level inputs to peripheral inputs\n\n- Programmable control of chip pad attributes like output drive-strength, pull-up, pull-down and virtual open-drain\n\n- Programmable pattern detectors to detect wakeup conditions during sleep mode\n\n- Programmable sleep mode behavior\n\n- Support for life-cycle-based JTAG (TAP) isolation and muxing\n",
  "spi_device": "# SPI Device HWIP Technical Specification\n\n[`spi_device`](https://reports.opentitan.org/hw/ip/spi_device/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/spi_device/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/spi_device/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/spi_device/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/spi_device/code.svg)\n\n# Overview\n\n## Features\n\n### SPI Flash/ Passthrough Modes\n\n- Support Serial Flash emulation\n  - HW processed Read Status, Read JEDEC ID, Read SFDP, EN4B/ EX4B, and multiple read commands\n  - 16 depth Command/ Address FIFOs and 256B Payload buffer for command upload\n  - 2x 1kB read buffer for read commands\n  - 1kB mailbox buffer and configurable mailbox target address\n- Support SPI passthrough\n  - Filtering of inadmissible commands (256-bit filter CSR)\n  - Address translation for read commands\n  - First 4B payload translation\n  - HW control of SPI PADs' output enable based on command information list\n  - SW configurable internal command process for Read Status, Read JEDEC ID, Read SFDP, and read access to the mailbox space\n  - Targets 33MHz @ Quad read mode, fall backs to 25MHz\n  - Optional pipelined reads to decrease timing pressure for passthrough mode\n- Automated tracking of 3B/ 4B address mode in the flash and passthrough modes\n- 24 entries of command information slots\n  - Configurable address/ dummy/ payload size per opcode\n\n### TPM over SPI\n\n- In compliance with [TPM PC Client Platform][TPM PCCP]\n- up to 64B compile-time configurable read and write data buffer (default: 4B)\n- 1 TPM command (8b) and 1 address (24bit) buffer\n- HW controlled wait state\n- Shared SPI with other SPI Device functionalities. Unique CS# for the TPM\n  - Flash or Passthrough mode can be active with TPM mode, with the shared pins allowing them to time-multiplex the bus.\n- HW processed registers for read requests during FIFO mode\n  - TPM_ACCESS_x, TPM_STS_x, TPM_INTF_CAPABILITY, TPM_INT_ENABLE, TPM_INT_STATUS, TPM_INT_VECTOR, TPM_DID_VID, TPM_RID\n  - TPM_HASH_START returns FFh\n- 5 Locality (compile-time parameter)\n\n## Description\n\nThe SPI device module consists of three functions, SPI Flash mode, SPI passthrough mode, and TPM over SPI mode.\n\nThe SW can receive TPM commands with payload (address and data) and respond to the read commands with the return data using the TPM submodule in the SPI_DEVICE HWIP.\nThe submodule provides the command, address, write, and read FIFOs for the SW to communicate with the TPM host system.\nThe submodule also supports the SW by managing a certain set of the FIFO registers and returning the read request by HW quickly.\n\nIn Flash mode, SPI Device HWIP behaves as a Serial Flash device by recognizing SPI Flash commands and processing those commands by HW.\nThe commands processed by HW are Read Status (1, 2, 3), Read JEDEC ID, Read SFDP, EN4B/ EX4B, and read commands with aid of SW.\nThe IP supports Normal Read, Fast Read, Fast Read Dual Output, Fast Read Quad Output.\nThis version of IP does not support Dual IO, Quad IO, QPI commands.\n\nIn Passthrough mode, SPI Device receives SPI transactions from a host system and forwards the transactions to a downstream flash device.\nSW may filter prohibited commands by configuring 256-bit [`FILTER`](doc/registers.md#filter) CSR.\nThe IP cancels ongoing transaction if the received opcode matches to the filter CSR by de-asserting CSb and gating SCK to the downstream flash device.\n\nSW may program CSRs to change the address and/or the first 4 bytes of payload on-the-fly in Passthrough mode.\nThe address translation feature allows SW to maintain A/B binary images without aids of the host system.\nThe payload translation may be used to change the payload of Write Status commands to not allow certain fields to be modified.\n\nIn Passthrough mode, parts of the Flash modules can be active.\nWhile in Passthrough mode, SW may configure the IP to process certain commands internally.\nSW is recommended to filter the commands being processed internally.\nMailbox is an exception as it shares the Read command opcode.\n\n### SPI Device Modes and Active Submodules\n\nSPI Device HWIP has two flash-like modes + TPM mode.\nFlash and Passthrough modes share many parts of the datapath.\nWith Flash mode, all commands target the internal node, and a special read buffer is available to stream data back to the host in FIFO style.\nWith Passthrough mode, commands may target the internal node and/or a downstream SPI flash, and the read buffer is not available.\nTPM mode only shares the SPI and has separate CSb port, which allows that the host sends TPM commands while other SPI mode is active.\n\nMode     | Status | JEDEC | SFDP | Mailbox | Read | Addr4B | Upload | Passthrough\n---------|--------|-------|------|---------|------|--------|--------|-------------\nFlash    |  Y     |   Y   |   Y  |   Y     |   Y  |   Y    |   Y    |\nPassthru |  Y/N   |  Y/N  |  Y/N |  Y/N    |   N  |   Y    |   Y    |     Y\n\n*Y/N*: Based on INTERCEPT_EN\n\n### Clocking Requirements\n\nSPI Device requires the core clock to have a frequency that is at least 1/4 the SPI clock frequency.\n\n## Compatibility\n\nThe SPI device supports emulating an EEPROM (SPI flash mode in this document).\nThe TPM submodule conforms to the [TPM over SPI 2.0][] specification. The TPM operation follows [TCG PC Client Platform TPM Profile Specification Section 7][TPM PCCP].\n\n[TPM over SPI 2.0]: https://trustedcomputinggroup.org/wp-content/uploads/Trusted-Platform-Module-Library-Family-2.0-Level-00-Revision-1.59_pub.zip\n[TPM PCCP]: https://trustedcomputinggroup.org/resource/pc-client-platform-tpm-profile-ptp-specification/\n",
  "i2c": "# I2C HWIP Technical Specification\n\n[`i2c`](https://reports.opentitan.org/hw/ip/i2c/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/i2c/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/i2c/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/i2c/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/i2c/code.svg)\n\n# Overview\n\nThis document specifies I2C hardware IP functionality.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top level system.\n\n## Features\n\n- Two-pin clock-data parallel bidirectional external interface: SCL (serial clock line) and SDA (serial data line)\n- Support for I2C Controller (\"I2C Master\"<sup>1</sup>) and I2C Target (\"I2C Slave\"<sup>1</sup>) device modes\n- Support for Standard-mode (100 kbaud), Fast-mode (400 kbaud) and Fast-mode Plus (1 Mbaud)\n- Bandwidth up to 1 Mbaud\n- Support for all \"Mandatory\" features as specified for I2C Controllers (as listed in Table 2 of the [I2C specification (revision 6)](https://web.archive.org/web/20210813122132/https://www.nxp.com/docs/en/user-guide/UM10204.pdf)):\n    - Start condition\n    - Stop condition\n    - Acknowledge (ACK)\n    - 7-bit target address\n- Support for the following optional capabilities:\n    - Clock stretching in the controller mode\n    - Automatic clock stretching in the target mode<sup>2</sup>\n    - Programmable automatic ACK control in the target mode\n- Support for multi-controller features:\n    - Controller-controller clock synchronization\n    - Controller bus arbitration\n    - Target responses to broadcast transfers (similar to arbitration)\n    - Bus idle detection\n- Byte-formatted register interface with four separate queues: two queues in the controller mode, one for holding read data (RX), the other for holding bytes to be transmitted (TX: addresses or write data) and two queues in the target mode, for holding read (RX) and write (TX) data\n- Direct SCL and SDA control in \"Override mode\" (for debugging)\n- SCL and SDA ports mapped to I/O via the pinmux\n- Interrupts in the controller mode for FMT and RX FIFO overflow, target NACK, SCL/SDA signal interference, timeout, unstable SDA signal levels, and transaction complete\n- Interrupts in the target mode for TX FIFO empty during a read, TX FIFO nonempty at the end of a read, TX overflow and ACQ FIFO full, controller sending STOP after ACK, and controller ceasing to send SCL pulses during an ongoing transaction\n- Loopback support with external controller when in target operation\n- SW may reset I2C block using the Reset Manager\n\n<sup>1</sup> lowRISC is avoiding the fraught terms master/slave and defaulting to controller/target where applicable.\n\n<sup>2</sup> The target is only compatible with controllers that support clock stretching.\nFor controllers that do not support clock stretching, it is expected that there must be an additional protocol to guarantee there is always sufficient space and data.\nThese protocols are not in scope of this document.\n\n## Description\n\nThis IP block implements the [I2C specification (rev. 6)](https://web.archive.org/web/20210813122132/https://www.nxp.com/docs/en/user-guide/UM10204.pdf), though with some variation in nomenclature.\nFor the purposes of this document, an \"I2C Controller\" meets the specifications put forth for a \"Master\" device.\nFurthermore, a device which meets the specifications put forward for an \"I2C Slave\" device is here referred to as an \"I2C Target\" or \"I2C Target Device\".\nNote that there are some places where \"host\" is used, such as in register and interrupt names.\nThis is equivalent to \"controller\" and comes from a time before more recent I2C and SMBus specifications settled on \"controller\" being the replacement.\nIt should not be confused with \"SMBus Host,\" which has a specific meaning in that protocol.\n\nAt a high-level, the I2C protocol is a clock-parallel serial protocol, with at least one controller issuing transactions to a number of targets on the same bus.\nA transaction may consist of multiple transfers, each of which has its own address byte and command bit (R/W).\nHowever, it is strongly recommended that all transfers in a transaction are issued to the same target address.\nMultiple controllers may begin a transaction simultaneously, but bus arbitration will cause only one stream of bits to reach a target.\nThis IP block can detect and report lost bus arbitration, and typically, the next action for software is to retry the transaction.\n\nEvery transfer consists of a number of bytes transmitted, either from controller-to-target or target-to-controller.\nEach byte is typically followed by a single bit acknowledgement (ACK) from the receiving side.\nTypically each transfer consists of:\n1. A START signal, issued by the controller.\n1. An address, issued by the controller, encoded using 7 bits.\n1. An R/W bit indicating if the transaction is a read-from or a write-to the target device.\nThe R/W bit is encoded along with the address.\n1. An acknowledge signal (ACK) sent by the target device.\n1. Data bytes, where the number of bytes required is indicated by the controller,\nin a manner which differs between reads and writes.\n    - For write transactions, the target device sends an ACK signal after every byte received.\n    The controller indicates the end of a transaction by sending a STOP or repeating the START signal.\n    - For read transactions, the target device continues to send data as long as the controller acknowledges the target-issued data by sending an ACK signal.\n    Once the controller has received all the required data it indicates that no more data is needed by explicitly de-asserting the ACK signal (this is called a NACK signal) just before sending a STOP or a repeated START signal.\n1. A STOP signal or a repeated START signal.\n\nAll well-behaved transactions end with a STOP signal, which indicates the end of the last transfer and when the bus is free again.\nHowever, this IP does support detection of bus timeouts, when there has been no activity for a specified amount of time.\n\nThis protocol is generally quite flexible with respect to timing constraints, and slow enough to be managed by a software microcontroller, however such an implementation requires frequent activity on the part of the microcontroller.\nThis IP presents a simple register interface and state-machine to manage the corresponding I/O pins directly using a byte-formatted programming model.\n\n## Compatibility\n\nThis IP block should be compatible with any target device covered by the [I2C specification (rev. 6)](https://web.archive.org/web/20210813122132/https://www.nxp.com/docs/en/user-guide/UM10204.pdf), operating at speeds up to 1 Mbaud.\nThis IP in the controller mode issues addresses in 7-bit encoding, and in the target mode, receives addresses in 7-bit encoding.\n(It remains the obligation of system designers to ensure that devices remain in a 7-bit address space.)\nThis IP also supports clock-stretching, should that be required by target devices.\n",
  "tlul": "# Bus Specification\n\n# Overview\n\nThis document specifies the bus functionality within a Comportable top level\nsystem. This includes the bus protocol and all hardware IP that supports\ncreating the network on chip within that framework.\n\n## Features\n\n- Support for multiple bus hosts and bus devices<sup>1</sup>\n- Support for multiple clock domains\n- Support for multiple outstanding requests\n- Extendability for 32b or 64b data widths\n- Extendability for flexible address widths\n- Extendability for security features\n- Low pin-count / area overhead\n- Support for transaction sizes up to bus width (byte, 2B, 4B); no\n  support for bursts\n- Suite of bus primitives to aid in fast fabric generation\n\n<sup>1</sup>lowRISC is avoiding the fraught terms master/slave and defaulting\nto host/device where applicable.\n\n## Description\n\nFor chip-level interconnect, Comportable devices will be using\n[TileLink](https://static.dev.sifive.com/docs/tilelink/tilelink-spec-1.7-draft.pdf)\nas its bus fabric protocol. For the purposes of our performance\nrequirement needs, the Uncached Lightweight (TL-UL) variant will\nsuffice. There is one minor modification to add the user extensions. This\nis highlighted below, but otherwise all functionality follows the official\nspecification. The main signal names are kept the same as TL-UL and the\nuser extension signal groups follow the same timing and naming conventions\nused in the TL-UL specification. Existing TL-UL IP blocks may be used\ndirectly in devices that do not need the additional sideband signals,\nor can be straightforwardly adapted to use the added features.\n\nTL-UL is a lightweight bus that combines the point-to-point\nsplit-transaction features of the powerful TileLink (or AMBA AXI)\n5-channel bus without the high pin-count overhead. It is intended to be\nabout on par of pincount with APB but with the transaction performance of\nAXI-4, modulo the following assumptions.\n\n- Only one request (read or write) per cycle\n- Only one response (read or write) per cycle\n- No burst transactions\n\nBus primitives are provided in the lowRISC IP library. These are\ndescribed later in this document. These primitives can be combined to form\na flexible crossbar of any M hosts to any N devices. As of this writing,\nthese crossbars are generated programmatically through usage of configuration files.\nSee the [tlgen reference manual](../../../util/tlgen/README.md) for more details.\n\n## Compatibility\n\nWith the exception of the user extensions, the bus is\ncompliant with TileLink-UL. The bus primitives, hosts and peripherals\ndeveloped using the extended specification can be used with\nblocks using the base specification. As a receiver baseline blocks\nignore the user signals and as a\nsource will generate a project-specific default value. Alternatively,\nthe blocks can be easily modified to make use of the user extensions.\n\n# Theory of Operations\n\n## Signals\n\nThe table below lists all of the TL-UL signals. \"Direction\" is\nw.r.t. a bus host, signals marked as output will be in the verilog\n`typedef struct` tagged as host-to-device (`tl_h2d_t`) and those marked\nas input will be in the device-to-host struct (`tl_d2h_t`). The literal\n`typedef structs` follow. Size qualifiers are described below. The table\nand structs include the additional (non-TL-UL standard) user extension\nsignals per direction to carry chip specific user bits.\n\nThe function of the user bits are separately described in a separate table.\n\n| Signal Name | Direction | Description |\n| --- | --- | --- |\n| `a_valid`           | output | Request from host is valid |\n| `a_ready`           | input  | Request from host is accepted by device |\n| `a_opcode[2:0]`     | output | Request opcode (read, write, or partial write) |\n| `a_param[2:0]`      | output | unused |\n| `a_address[AW-1:0]` | output | Request address of configurable width |\n| `a_data[DW-1:0]`    | output | Write request data of configurable width |\n| `a_source[AIW-1:0]` | output | Request identifier of configurable width |\n| `a_size[SZW-1:0]`   | output | Request size (requested size is 2^`a_size`, thus 0 = byte, 1 = 16b, 2 = 32b, 3 = 64b, etc) |\n| `a_mask[DBW-1:0]`   | output | Write strobe, one bit per byte indicating which lanes of data are valid for this write request |\n| `a_user`            | output | Request attributes of configurable width, use TBD. **This is an augmentation to the TL-UL specification.** |\n| `d_valid`           | input  | Response from device is valid |\n| `d_ready`           | output | Response from device is accepted by host |\n| `d_opcode[2:0]`     | input  | Response opcode (Ack or Data) |\n| `d_error`           | input  | Response is in error |\n| `d_param[2:0]`      | input  | Response parameter (unused) |\n| `d_size[SZW-1:0]`   | input  | Response data size |\n| `d_data[DW-1:0]`    | input  | Response data of configurable width |\n| `d_source[AIW-1:0]` | input  | Bouncing of request ID of configurable width |\n| `d_sink[DIW-1:0]`   | input  | Response ID of configurable width (possibly unused) |\n| `d_user[DUW-1:0]`   | input  | Response attributes of configurable width; includes error responses plus other attributes TBD. **This is an augmentation to the TL-UL specification.** |\n\nThe `a_user` bus contains several signals\n- `instr_type` - controls whether the transaction is an instruction fetch type\n- `cmd_intg`   - carries the command integrity of the transaction\n- `data_intg`  - carries the write data integrity of the transaction\n\nThe `d_user` bus contains several signals\n- `rsp_intg`   - carries the response integrity of the transaction\n- `data_intg`  - carries the read data integrity of the transaction\n\nThe user bus is primarily used to distinguish data / instruction transactions while also supporting the bus integrity scheme.\n\nThere are eight bus width parameters, defined here. Some are generated\nwidths based upon the other parameter sizes.\n\n- `AW`: width of address bus, default 32\n- `DW`: width of data bus, default 32\n- `DBW`: number of data bytes, generated == `DW/8`\n- `SZW`: size width, covers 2^(x) <= `DBW`; (2 bit for 4B)\n- `AIW`: width of address source (ID) bus, default 8\n- `DUW`: width of device user bits, default 4\n- `DIW`: width of sink bits, default 1\n\nAll widths are expected to be fixed for an entire project and referred\nto in (what is currently called) `top_pkg`. The contents of `top_pkg`\n(to define the widths) and `tlul_pkg` (to define the bus structs) are\ngiven below.\n\n### Reset Timing\n\nSection 3.2.2 of the\n[TileLink specification (1.7.1)](https://sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf)\nhas a requirement on TL-UL hosts (\"masters\" in TileLink terminology) that \"`valid` signals must be driven LOW for at least 100 cycles while reset is asserted.\"\nThe TL-UL collateral within this library does **not** have this requirement on its TL-UL host drivers.\nTL-UL devices within the library can tolerate shorter reset windows.\n(See the reset section of the [Comportability Specification](../../../doc/contributing/hw/comportability/README.md)\nfor details on reset requirements.)\n\n### Signal and Struct Definitions\n\nThe following shows Verilog structs to define the above parameters\nand signals.\n\n```systemverilog\npackage top_pkg;\n  localparam TL_AW=32;\n  localparam TL_DW=32;\n  localparam TL_AIW=8;\n  localparam TL_DIW=1;\n  localparam TL_DUW=4;\n  localparam TL_DBW=(TL_DW>>3);\n  localparam TL_SZW=$clog2($clog2(TL_DBW)+1);\nendpackage\n```\n\n```systemverilog\npackage tlul_pkg;\n  typedef enum logic [2:0] {\n    PutFullData    = 3'h 0,\n    PutPartialData = 3'h 1,\n    Get            = 3'h 4\n  } tl_a_op_e;\n  typedef enum logic [2:0] {\n    AccessAck     = 3'h 0,\n    AccessAckData = 3'h 1\n  } tl_d_op_e;\n\n  typedef struct packed {\n    logic [6:0] rsvd1; // Reserved for future use\n    logic       parity_en;\n    logic [7:0] parity; // Use only lower TL_DBW bit\n  } tl_a_user_t;\n\n  typedef struct packed {\n    logic                         a_valid;\n    tl_a_op_e                     a_opcode;\n    logic                  [2:0]  a_param;\n    logic  [top_pkg::TL_SZW-1:0]  a_size;\n    logic  [top_pkg::TL_AIW-1:0]  a_source;\n    logic   [top_pkg::TL_AW-1:0]  a_address;\n    logic  [top_pkg::TL_DBW-1:0]  a_mask;\n    logic   [top_pkg::TL_DW-1:0]  a_data;\n    tl_a_user_t                   a_user;\n\n    logic                         d_ready;\n  } tl_h2d_t;\n\n  typedef struct packed {\n    logic                         d_valid;\n    tl_d_op_e                     d_opcode;\n    logic                  [2:0]  d_param;\n    logic  [top_pkg::TL_SZW-1:0]  d_size;\n    logic  [top_pkg::TL_AIW-1:0]  d_source;\n    logic  [top_pkg::TL_DIW-1:0]  d_sink;\n    logic   [top_pkg::TL_DW-1:0]  d_data;\n    logic  [top_pkg::TL_DUW-1:0]  d_user;\n    logic                         d_error;\n\n    logic                         a_ready;\n  } tl_d2h_t;\n\nendpackage\n```\n\n### Usage of Signals\n\n#### Usage of Address\n\nAll signaling for host-request routing is encapsulated in the `a_addr` signal.\n(See section 5.3 of the TileLink specification).\nFor a bus host to designate which device it is talking to, it only needs to indicate the correct device register/memory address.\nThe other host signals (namely `a_source` and `a_user`) do not enter into the address calculation.\nAll request steering must thus be made as a function of the address.\n\n#### Usage of Source and Sink ID Bits\n\nThe `a_source` and `d_source` signals are used to steer the response from\na device back to a host through bus primitives. (See primitives section\nthat follows). It can also be used to ascribe request identifiers by a\nhost when response reordering is required (since TL-UL does not guarantee\nin-order responses). For permission detection, static host identifiers\nwill be transmitted in the user field (see below).\n\nSome bus primitives, such as `M:1` sockets, need to add source bits\nduring request routing in order to be able to correctly route the\nresponse. For instance, if one destination is addressed by N potential\nhosts, log<sub>2</sub>N more source ID bits need to be added to the\noutgoing request. The fabric architect needs to ensure that the attribute\n`AIW` is big enough to cover the number of outstanding requests hosts\ncan make and the maximum source ID growth that could be added by bus\nprimitives. At this time, `AIW` is assumed to be 8 bits of ID growth, but\nthis is likely overkill. The fabric also needs to allow for how many host\nID bits are needed, for instance if converting from an AXI host that uses\n`RID` or `WID`, enough bits must be provided to maintain those ID values.\n\n##### Source ID growth\n\nWhen a bus primitive needs to add source ID bits, it shifts left the\nincoming `a_source` and post-pends its necessary sub-source bits. For\ninstance, if a 5:1 socket is needed, 3 sub-source bits are generated to\ndistinguish between hosts 0 through 4. So an 8-bit outgoing `a_source`\nwould be `{a_source_inbound[4:0],subsource[2:0]}`. When the response\nreturns, those 3 sub-source bits are shifted off, with `'0'` bits\nshifted into the top, and returned to the originator's `d_source`. It\nis recommended to have assertions in place to ensure no significant bits\nof `a_source` are lost in `M:1` sockets. See the `M:1` socket primitive\nfor more details.\n\n##### Source ID requirements for host elements\n\nThe potential for source ID growth (and contraction in the response)\nimplies that hosts may only use the low bits of the identifier and cannot\nassume the entire `AIW` bits will be returned intact. If there are any hosts\nthat need more source bits returned than the host's maximum number of\noutstanding transactions (for example the host uses some source bits as\ninternal sub-unit identifiers and some bits as transaction IDs from that\nsubunit) then the `AIW` value needs to be set accordingly.\n\n##### Source ID requirements for device elements\n\nAll bus devices must simply return the associated `a_source` on the\nresponse `d_source` bus.\n\n##### Source ID requirements for bus primitives\n\nMost bus primitives simply pass source ID bits opaquely from host end to\ndevice end. The exception is for `M:1` sockets (see ID growth above). Other\nelements (`1:N` sockets, domain crossing FIFOs, etc) should not modify\nthe `a_source` and `d_source` values, but pass them along.\n\n##### Sink ID Usage\n\nAt this time there is no defined use for `d_sink`, but the TileLink-UL\nprotocol allows configurable bits to be passed back to the host to\nindicate who responded. In theory this could be used as a security\nguarantee, to ensure that the appropriate responder was targeted. At\nthis time the configurable width for sink is turned down to one bit.\n\n#### Usage of User Bits\n\nUser bits are added to the TileLink-UL specification in order to prepare\nfor command and response modification in future IP. These are effectively\nmodifiers to the transactions that can qualify the request and the\nresponse. The user bits follow the same timing as the source ID bits:\n`a_user` matches `a_source` and `d_user` matches `d_source`. Usage of\nuser bits within a project must be assigned project-wide, but the bus\nfabric does not rely on them for transport, and should pass the user\nbits on blindly. Bus hosts and devices must understand their usage and\napply them appropriately.\n\nThe following list gives examples of future usage for `a_user` and\n`d_user` bits.\n\n- `a_user` modifications\n  - Instruction Type\n    - This indicates whether the transaction originates from a code fetch or data fetch.\n    - This attribute is used by downstream consumers to provide separate privilege control based on transaction type.\n  - Command Integrity\n    - This is the calculated integrity of the instruction type, transaction address, transaction op code and mask.\n    - The integrity is checked by downstream consumers to ensure the transaction has not been tampered.\n\n  - Data Integrity\n    - This is calculated integrity of the write data.\n    - The integrity is checked by downstream consumers to ensure the transaction has not been tampered.\n\n- `d_user` modifications\n  - Response Integrity\n    - This is the calculated integrity of the response op code, response size and response error.\n    - This integrity is checked by the transaction originator to ensure the response has not been tampered.\n\n  - Data Integrity\n    - This is the calculated integrity of the response read data.\n    - This integrity is checked by the transaction originator to ensure the response has not been tampered.\n\n#### Usage of Opcode, Size and Mask\n\nThe request opcode (`a_opcode`) can designate between a write (`'Put'`)\nand a read (`'Get'`) transaction. Writes can be designated as full\n(`'PutFullData'`) or partial (`'PutPartialData'`) within the opcode\nspace. The request size (`a_size`) and mask (`a_mask`) is defined for\nall read and write operations. Opcode (`a_opcode`) definitions are\nshown below. Responses also have opcodes (`d_opcode`) to indicate read\nresponse (`'AccessAckData'`) and write response (`'AccessAck'`). Error\nindications are available on either with the `d_error` bit. Each bus\ndevice has an option to support or not support the full variety of\nbus transaction sizes. Their support will be documented in the device\nspecification.\n\nIt should be noted that, even though non-contiguous `a_mask` values like\n`0b1001` are permitted by the TL-UL spec, the TL-UL hosts within this project\n**do not leverage non-contiguous masks**. I.e., the TL-UL hosts will only assert\n`a_mask` values from the following restricted set for 32bit transfers:\n```\n{'b0000, 'b0001, 'b0010, 'b0100, 'b1000, 'b0011, 'b0110, 'b1100, 'b0111, 'b1110, 'b1111}.\n```\nThe TL-UL devices within the project may or may not support certain subword\nmasks (both non-contiguous or contiguous ones), and they have the right to\nassert `d_error` if they don't.\n\n| `a_opcode[2:0]` value | Name | Definition |\n| :---: | :---: | --- |\n| `3'b000` | `PutFullData` | Write of full bus width. `a_size` should be `'h2` to indicate 32b write (or `'h3` if/when 64b bus width is supported), though the bus specification allows these to be defined otherwise (see `PutPartialData` below) |\n| `3'b001` | `PutPartialData` | Write of partial bus width. `a_size[SZW-1:0]` indicates how many bytes are transmitted. The encoding is `2^a_size` so `'h0` indicates 1 byte, `'h1` indicates 2 bytes, `'h2` indicates 4 bytes, etc. The lower bits of `a_address` are valid to indicate sub-word addressing, and the bits of `a_mask[DBW-1:0]` should indicate valid byte lanes. |\n| `3'b100` | `Get` | Read of full bus width. The bus specification allows these to be defined otherwise (see PutPartialData above) for reads of sub-bus-width. |\n| `3'b01x, 3'b101, 3'b11x` | `undefined` | All other opcodes are undefined. Bus devices should return an error. |\n\n| `d_opcode[2:0]` value | Name | Definition |\n| :---: | :---: | --- |\n| `3'b000` | `AccessAck` | Write command acknowledgement, no data |\n| `3'b001` | `AccessAckData` | Read command acknowledgement, data valid on `d_data` |\n| `3'b01x, 3'b1xx` | `undefined` | All other opcodes are undefined and should return an error. |\n\n#### Explicit Error Cases\n\nThe TL-UL devices in this project contain a set of HW protocol checkers that raise a runtime error (`d_error`) if the request is in violation.\nIn particular, the following properties are checked:\n\n1. Wrong opcode,\n2. Wrong combination of `a_addr[1:0]`, `a_size`, `a_mask`, for example:\n  - `a_size` must not be greater than `2`,\n  - Inactive lanes must be marked with `'b0` in `a_mask`,\n  - `PutFullData` must mark all active lanes with a `'b1` in `a_mask`,\n3. Non-contiguous mask may lead to an error, depending on the device support (see previous section),\n4. Register files always assume aligned 32bit accesses, see also [register tool manual](../../../util/reggen/README.md#error-responses),\n5. Accesses to non-existent addresses.\n\nOn the host side, orphaned responses (i.e. responses that do not have a valid request counterpart) and responses with the wrong opcode will be discarded.\nIt is planned to raise a critical hardware error that can be detected and reacted upon via other subsystems in those cases, but that feature has not been implemented yet.\n\nNote that the above checks also cover cases which are in principle allowed by the TL-UL spec, but are not supported by the hosts and devices within this project.\nFurther, devices and hosts may implement additional more restrictive checks, if needed.\n\nThe remaining, basic properties as specified in the TL-UL spec are enforced at design time using assertions, and hence no additional hardware checkers are implemented to check for those properties (see also [TL-UL Protocol Checker Specification](./doc/TlulProtocolChecker.md)).\n\nThe interconnect does not possess additional hardware mechanisms to detect and handle interconnect deadlocks due to malicious tampering attempts.\nThe reasons for this are that\n1. the space of potential errors and resolutions would be very large, thus unnecessarily complicating the design,\n2. any tampering attempt leading to an unresponsive system will eventually be detected by other subsystems within the top level system.\n\n### Bus Integrity Scheme\nTo be filled in.\n\n\n## Timing Diagrams\n\nThis section shows the timing relationship on the bus for writes with\nresponse, and reads with response. This shows a few transactions, see\nthe TileLink specification for more examples.\n\n```wavejson\n{\n  signal: [\n    { name: 'clk_i',      wave: 'p...................' },\n    { name: 'a_valid',    wave: '0.1....0101...0.....' },\n    { name: 'a_ready',    wave: '0.1..01010...10.....' },\n    { name: 'a_source',   wave: '0.3333.0303...0.....', data: ['I0','I1','I2','I3','I4','I5'] },\n    { name: 'a_opcode',   wave: '0.3..3.0303...0.....', data: ['put-full','put-partial','pf', 'put-partial'] },\n    { name: 'a_addr',     wave: '703333.0303...7.....', data: ['A0', 'A1','A2','A3','A4','A5'] },\n    { name: 'a_data',     wave: '703333.0303...7.....', data: ['D0', 'D1','D2','D3','D4','D5'] },\n    { name: 'a_size',     wave: '703..3.0303...7.....', data: ['2', '0','2','1'] },\n    { name: 'a_mask',     wave: '7...03.7703...7.....', data: ['M3', 'M5'] },\n    { name: 'a_user',     wave: '0.3333.0303...0.....', data: ['AU0','AU1','AU2','AU3','AU4','AU5'] },\n    {},\n    { name: 'd_valid',   wave: '0....1....0101....0.' },\n    { name: 'd_ready',   wave: '0......1..010...1.0.' },\n    { name: 'd_source',  wave: '7...03..330304...38.', data: ['I0','I1','I2','I3','I4','I5'] },\n    { name: 'd_opcode',  wave: '7...03....0304...38.', data: ['ACK','ACK','ACK'] },\n    { name: 'd_user',    wave: '7...03..330304...38.', data: ['DU0','DU1','DU2','DU3','DU4','DU5'] },\n    { name: 'd_error',   wave: '0............1...0..' },\n  ],\n  head: {\n    text: 'TileLink-UL write transactions',\n  },\n  foot: {\n    text: 'six write transactions (four full, two partial) with various req/ready delays, error on I4 response',\n    }\n}\n```\n\n```wavejson\n{\n  signal: [\n    { name: 'clk_i',    wave: 'p...................' },\n    { name: 'a_valid',  wave: '0.1....0101...0.....' },\n    { name: 'a_ready',  wave: '0.1..01010...10.....' },\n    { name: 'a_source', wave: '703333.0303...7.....', data: ['I0', 'I1','I2','I3','I4','I5'] },\n    { name: 'a_opcode', wave: '0.3....0303...7.....', data: ['get', 'get', 'get'] },\n    { name: 'a_addr',   wave: '703333.0303...7.....', data: ['A0', 'A1','A2','A3','A4','A5'] },\n    { name: 'a_user',   wave: '703333.0303...7.....', data: ['AU0', 'AU1','AU2','AU3','AU4','AU5'] },\n    {},\n    { name: 'd_valid',  wave: '0....1....0101....0.' },\n    { name: 'd_ready',  wave: '0......1..010...1.0.' },\n    { name: 'd_source', wave: '7...03..330304...38.', data: ['I0', 'I1','I2','I3','I4','I5'] },\n    { name: 'd_data',   wave: '7...03..330304...38.', data: ['D0', 'D1','D2','D3','D4','D5'] },\n    { name: 'd_opcode', wave: '7...03....0304...38.', data: ['DATA', 'DATA','DATA','DATA'] },\n    { name: 'd_user',   wave: '7...03..330304...38.', data: ['DU0', 'DU1','DU2','DU3','DU4','DU5'] },\n    { name: 'd_error',  wave: '0............1...0..', data: ['ACK', 'ACK','ACK','ACK','ERR','ACK'] },\n  ],\n  head: {\n    text: 'TileLink-UL read transactions',\n  },\n  foot: {\n    text: 'six read transactions with various req/ready delays, error on I5 response',\n    }\n}\n```\n\n## Bus Primitives\n\nThe bus primitives are defined in the following table and described in\ndetail below.\n\n| Element | Description |\n| :---: | --- |\n| `tlul_fifo_sync` | FIFO connecting one TL-UL host to one TL-UL device in a synchronous manner. Used to create elasticity in the bus, or as a sub-element within other elements. TL-UL protocol is maintained on both sides of the device. Parameters control many features of the FIFO (see detailed description that follows). |\n| `tlul_fifo_async` | FIFO connecting one TL-UL host to one TL-UL device in an asynchronous manner. Used to create elasticity in the bus, or to cross clock domains, or as a sub-element within other elements. TL-UL protocol is maintained on both sides of the device. Parameters control many features of the FIFO (see detailed description that follows). |\n| `tlul_socket_1n` | Demultiplexing element that connects 1 TL-UL host to N TL-UL devices. TL-UL protocol is maintained on the host side and with all devices. Parameter settings control many of the features of the socket (see detailed description that follows). |\n| `tlul_socket_m1` | Multiplexing element that connects M TL-UL hosts to 1 TL-UL device. TL-UL protocol is maintained with all hosts and on the device side. Parameter settings control many of the features of the socket (see detailed description that follows). |\n| `tlul_xbar` | Crossbar that connects M TL-UL hosts with N TL-UL devices. The connectivity matrix may be sparse, and not all nodes are required to be the same clock or reset domain.  TL-UL protocol is maintained with all hosts and with all devices. Parameters and configuration settings control many of the features of the switch. This is not specified at this time, and will be done at a later date based upon project goals. |\n| `tlul_adapter_sram` | Adapter that connects a TL-UL host to an sram type interface. |\n\n#### A Note on Directions\n\nIn each of these devices, ports are named with respect to their usage,\nnot their direction. For instance, a `1:N` socket connects one host to\nN devices. Thus the TL-UL port coming in is called the \"host bus\",\nand the N device ports are called \"device bus\" 0 through N-1. Within\nthe Verilog module, the \"host bus\" is actually a device in the sense\nthat it receives requests and returns responses. This terminology can be\nconfusing within the bus element itself but should maintain consistency\nin naming at the higher levels.\n\n### `tlul_fifo_sync`\n\nThe TL-UL FIFO is a `1:1` bus element that provides elasticity (the\nability for transactions to stall on one side without affecting the other\nside) on the bus. It is also used as a sub-element in other elements, like\nsockets. Parameterization of the module is described in the table below.\n\n| name | description |\n| :---: | --- |\n| `ReqPass` | If 1, allow requests to pass through the FIFO with no clock delay if the request FIFO is empty (this may have timing implications). If false, at least one clock cycle of latency is created. Default is 1. |\n| `RspPass` | If 1, allow responses to pass through the FIFO with no clock delay if the response FIFO is empty (this may have timing implications). If false, at least one clock cycle of latency is created. Default is 1. |\n| `ReqDepth[4]` | Depth of request FIFO. Depth of zero is allowed only if `ReqPass` is 1. The maximum value for `ReqDepth` is 15. Default is 2. |\n| `RspDepth[4]` | Depth of response FIFO. Depth of zero is allowed only if `RspPass` is 1. The maximum value for `RspDepth` is 15. Default is 2. |\n| `SpareReqW` | The FIFO has spare bits in the request direction for auxiliary use by other bus elements. This parameter defines the size, default 1, must be >= 1 to avoid compilation errors. If the bit is not needed, the spare input should be tied to zero, and the spare output ignored. |\n| `SpareRspW` | The FIFO has spare bits in the response direction for auxiliary use by other bus elements. This parameter defines the size, default 1, must be >= 1 to avoid compilation error. If the bit is not needed, the spare input should be tied to zero, and the spare output ignored. |\n\nWhen `Pass` is 1 and its corresponding `Depth` is 0, the FIFO feeds through the signals completely.\nThis allows more flexible control at compile-time on the FIFO overhead / latency trade-off without needing to re-code the design.\n\nThe IO of the module are given in this table. See the struct above for\nTL-UL typedef definitions.\n\n| direction | type / size | name | description |\n| :---: | :---: | :---: | --- |\n| `input`  | | `clk_i` | clock |\n| `input`  | | `rst_ni` | active low reset |\n| `input`  | `tl_h2d_t` | `tl_h_i` | Incoming host request struct |\n| `output` | `tl_d2h_t` | `tl_h_o` | Outgoing host response struct |\n| `output` | `tl_h2d_t` | `tl_d_o` | Outgoing device request struct |\n| `input`  | `tl_d2h_t` | `tl_d_i` | Incoming device response struct |\n| `input`  | `[SpareReqW-1:0]` | `spare_req_i` | Spare request bits in|\n| `output` | `[SpareReqW-1:0]` | `spare_req_o` | Spare request bits out |\n| `input`  | `[SpareRspW-1:0]` | `spare_rsp_i` | Spare response bits in |\n| `output` | `[SpareRspW-1:0]` | `spare_rsp_o` | Spare response bits out |\n\n### `tlul_fifo_async`\n\nThe TL-UL asynchronous FIFO is a `1:1` bus element that can be used to\ncross clock domains. Parameterization of the module is described in the\ntable below.\n\n| name | description |\n| :---: | --- |\n| `ReqDepth[4]` | Depth of request FIFO. Depth of request FIFO. ReqDepth must be >= 2, and the maximum value is 15. |\n| `RspDepth[4]` | Depth of response FIFO. RspDepth must be >= 2, and the maximum value is 15. |\n\nThe IO of the module are given in this table. See the struct above for\nTL-UL typedef definitions.\n\n| direction | type / size | name | description |\n| :---: | :---: | :---: | --- |\n| `input`  | | `clk_h_i` | Host side clock |\n| `input`  | | `rst_h_ni` | Host side active low reset |\n| `input`  | | `clk_d_i` | Device side clock |\n| `input`  | | `rst_d_ni` | Device side active low reset |\n| `input`  | `tl_h2d_t` | `tl_h_i` | Incoming host request struct |\n| `output` | `tl_d2h_t` | `tl_h_o` | Outgoing host response struct |\n| `output` | `tl_h2d_t` | `tl_d_o` | Outgoing device request struct |\n| `input`  | `tl_d2h_t` | `tl_d_i` | Incoming device response struct |\n\n### `tlul_socket_1n`\n\nThe TL-UL socket `1:N` is a bus element that connects 1 TL-UL host\nto N TL-UL devices. It is a fundamental building block of the TL-UL\nswitch, and uses `tlul_fifo_sync` as its building block. It has a\nseveral parameterization settings available, summarized here. Note\n`tlul_socket_1n` is always synchronous. If asynchronous behavior is\ndesired, an `tlul_fifo_async` should be placed on the desired bus.\n\n| name | description |\n| :---: | --- |\n| `N` | Number of devices the socket communicates with, 2 <= N <= 15. |\n| `HReqPass` | If 1, allow requests to pass through the host-side FIFO with no clock delay if the request FIFO is empty. If 0, at least one clock cycle of latency is created. Default is 1. |\n| `HRspPass` | If 1, allow responses to pass through the host-side FIFO with no clock delay if the response FIFO is empty. If 0, at least one clock cycle of latency is created. Default is 1. |\n| `HReqDepth[4]` | Depth of host-side request FIFO. Depth of zero is allowed if `ReqPass` is 1. A maximum value of 15 is allowed, default is 2. |\n| `HRspDepth[4]` | Depth of host-side response FIFO. Depth of zero is allowed if `RspPass` is 1. A maximum value of 15 is allowed, default is 2. |\n| `DReqPass[N]` | If 1, allow requests to pass through device i FIFO with no clock delay if the request FIFO is empty. If false, at least one clock cycle of latency is created. Default is 1. |\n| `DRspPass[N]` | If 1, allow responses to pass through the device i FIFO with no clock delay if the response FIFO is empty. If 0, at least one clock cycle of latency is created. Default is 1. |\n| `DReqDepth[N*4]` | Depth of device i request FIFO. Depth of zero is allowed if `ReqPass` is 1. A maximum value of 15 is allowed, default is 2. |\n| `DRspDepth[N*4]` | Depth of device i response FIFO. Depth of zero is allowed if `RspPass` is 1. A maximum value of 15 is allowed, default is 2. |\n\nThe diagram below shows the dataflow of the `tlul_socket_1n` and how\nthe `tlul_fifo_sync` modules are allocated.\n\n![tlul_socket_1n block diagram](./doc/tlul_socket_1n.svg)\n\nIn this diagram, the full socket (`1:4` in this case) is shown, with\nits single host port and four device ports. Also shown is the critical\ndevice select input, which controls the transaction steering. To allow\nflexibility the address decoding is done outside the socket. The TL-UL\nspecification requires that the decode only use the address bits, but no\nother constraints are placed on how the external decode logic converts\nthe address to the output device selection signal (`dev_sel`). The\ntiming of `dev_sel` is such that it must be valid whenever `a_valid`\nis true in order to steer the associated request.\n\nThe address decoder can trigger an error response: if the value of\n`dev_sel` is not between 0 and N-1, then `tlul_socket_1n` will provide\nthe error response to the request. This is implemented with a separate\npiece of logic inside the socket which handles all requests to `dev_sel >=\nN` and replies with an error.\n\nThe IO of the socket are given in this table. See the struct above for\nTL-UL `typedef` definitions.\n\n| direction | type / size | name | description |\n| :---: | :---: | :---: | --- |\n| `input`  | | `clk_i` | clock |\n| `input`  | | `rst_ni` | active low reest |\n| `input`  | `tl_h2d_t` | `tl_h_i` | incoming host request struct |\n| `output` | `tl_d2h_t` | `tl_h_o` | outgoing host response struct |\n| `output` | `tl_h2d_t` | `tl_d_o[N]` | Outgoing device request struct for device port *i* (where *i* is from 0 to *N-1*) |\n| `input`  | `tl_d2h_t` | `tl_d_i[N]` | Incoming device response struct for device port *i* (where *i* is from 0 to *N-1*) |\n| `input`  | `[log2(N+1)-1:0]` | `dev_sel` | Device select for the current transaction provided in `tl_h_i` bus. Legal values from 0 to N-1 steer to the corresponding device port. Any other value returns an automatic error response.  |\n\nIn the current implementation, outstanding requests are tracked so that\nno new requests can go to a device port if there already are outstanding\nrequests to a different device. This ensures that all transactions are\nreturned in order. This feature is still in discussion.\n\n### `tlul_socket_m1`\n\nThe TL-UL socket `M:1` is a bus element that connects `M` TL-UL\nhosts to 1 TL-UL device. Along with a `tlul_socket_1n`, this could\nbe used to build the TL-UL fabric, and uses `tlul_fifo` as its\nbuilding block. `tlul_socket_m1` has several parameterization settings\navailable. The `tlul_socket_m1` is synchronous, so a `tlul_fifo_async`\nmust be instantiated on any ports that run asynchronously.\n\n| name | description |\n| :---: | --- |\n| `M` | Number of hosts the socket communicates with, 2 <= M <= 15. |\n| `HReqPass[M]` | `M` bit array to allow requests to pass through the host i FIFO with no clock delay if the request FIFO is empty. If `1'b0`, at least one clock cycle of latency is created. Default is `1'b1`. |\n| `HRspPass[M]` | `M` bit array. If `bit[i]=1`, allow responses to pass through the host *i* FIFO with no clock delay if the response FIFO is empty. If false, at least one clock cycle of latency is created. Default is 1. |\n| `HReqDepth[4*M]` | `Mx4` bit array. `bit[i*4+:4]` is depth of host *i* request FIFO. Depth of zero is allowed if `ReqPass` is true. A maximum value of 15 is allowed, default is 2. |\n| `HRspDepth[4*M]` | `Mx4` bit array. `bit[i*4+:4]` is depth of host *i* response FIFO. Depth of zero is allowed if RspPass is true. A maximum value of 15 is allowed, default is 2. |\n| `DReqPass` | If 1, allow requests to pass through device FIFO with no clock delay if the request FIFO is empty. If false, at least one clock cycle of latency is created. Default is 1. |\n| `DRspPass` | If 1, allow responses to pass through the device FIFO with no clock delay if the response FIFO is empty. If false, at least one clock cycle of latency is created. Default is 1. |\n| `DReqDepth[4]` | Depth of device i request FIFO. Depth of zero is allowed if `ReqPass` is true. A maximum value of 15 is allowed, default is 2. |\n| `DRspDepth[4]` | Depth of device i response FIFO. Depth of zero is allowed if `RspPass` is true. A maximum value of 15 is allowed, default is 2. |\n\nThe diagram below shows the dataflow of `tlul_socket_m1` for `4:1`\ncase and how the `tlul_fifo_sync` modules are allocated.\n\n![tlul_socket_m1 block diagram](./doc/tlul_socket_m1.svg)\n\nRequests coming from each host ports are arbitrated in the socket based\non round-robin scheme. `tlul_socket_m1`, unlike the `1:N` socket, doesn't\nrequire the `dev_sel` input. As the request is forwarded, the request ID\n(`a_source`) is modified as described in the ID Growth section. The ID\nreturned with a response (`d_source`) can thus be directly used to steer\nthe response to the appropriate host.\n\nThe IO of `M:1` socket are given in this table. See the struct above for\nTL `typedef` definitions.\n\n| direction | type / size | name | description |\n| :---: | :---: | :---: | --- |\n| `input`  |            | `clk_i`     | clock |\n| `input`  |            | `rst_ni`    | active low reest |\n| `input`  | `tl_h2d_t` | `tl_h_i[M]` | unpacked array of incoming host request structs |\n| `output` | `tl_d2h_t` | `tl_h_o[M]` | unpacked array of outgoing host response structs |\n| `output` | `tl_h2d_t` | `tl_d_o`    | outgoing device request struct |\n| `input`  | `tl_d2h_t` | `tl_d_i`    | incoming device response struct |\n\n### `tlul_xbar`\n\nFor details of the `tlul_xbar`, please refer to the [tlgen reference manual](../../../util/tlgen/README.md).\nIn general, tlgen stitches together various components described in the previous sections to create a full blown fabric switch.\nSpecifically, it implements the address to `dev_sel` steering logic and ensures the right connections are made from host to device.\n\n\n### `tlul_adapter_sram`\n\nThe TL-UL sram adapter is a bus element that connects a TL-UL interface to a memory like interface.\nThe memory interface is defined as follows:\n\n| name    | direction | description                            |\n| :---:   | :---:     | :---:                                  |\n| req     | `output`  | Memory interface transaction request   |\n| gnt     | `input`   | Memory interface transaction grant     |\n| we      | `output`  | Transaction write enable               |\n| addr    | `output`  | Transaction address                    |\n| wdata   | `output`  | Transaction write data                 |\n| wmask   | `output`  | Transaction write mask                 |\n| rvalid  | `input`   | Transaction read valid from downstream |\n| rdata   | `input`   | Transaction read data from downstream  |\n| rerror  | `input`   | Transaction read error from downstream |\n\nThe diagram below is a block diagram that shows the construction of the adapter.\n![tlul_adapter_sram_block diagram](./doc/tlul_adapter_sram.svg)\n\nAll incoming transactions are checked for protocol errors and integrity.\nThe transactions are then forwarded to the `tlul_sram_byte` module, which determines whether the incoming transaction is a write, and whether the write transaction must be transformed to a read-modified-write.\n\nThe transformation is done when integrity is enabled on the downstream storage and the incoming transaction is a legal partial write.\nDuring this scenario, in order to correctly compute the storage integrity, the adapter must first read back whatever is present in memory so that the full integrity can be computed.\nIf an error is present during the protocol and integrity checks, or if the transaction is not a partial write (read or full write), then the transaction is passed through directly to the TL-UL-sram conversion.\nIf the transaction is a legal partial write, the `tlul_sram_byte` instead transforms the transaction into two: a full read followed by a full write for a read-modified-write of the intended address.\n\nOnce past the `tlul_sram_byte`, a transaction accepted by downstream consumers has some of its attributes (type of operation, presence of error, size, source) stored in the `request fifo`.\nThis is needed to correctly construct the TL-UL d-channel response when the transaction is complete.\n\nThe internally computed \"read mask\" is also stored in the `sramreqfifo` for read transactions.\nThis is needed to correctly mask off uninteresting bytes during a partial read.\n\nAny returning read data from downstream is stored inside the `rspfifo`.\nThis is needed in case the upstream TL-UL host back pressures the d-channel.\n\n#### Life of a Write Transaction\nWhen a write transaction is received, the above steps are followed; however, nothing is stored in the `sramreqfifo`.\nWhen downstream completes the write transaction, the stored `reqfifo` entry is used to construct the TL-UL response.\nWhen the response is accepted by an upstream TL-UL host, the `reqfifo` entry popped.\n\n#### Life of a Read Transaction\nWhen a read transaction is received, both the `reqfifo` and the `sramreqfifo` store a new entry.\nThe former stores transaction attributes, while the latter stores the read mask and read offset (in case the downstream read is larger than TL-UL bus width).\nWhen downstream completes the read transaction through `rvalid_i`, the relevant data, as determined by the stored read mask and offset in `sramreqfifo`, is stored in the `rspfifo`.\nThe act of storing into the `rspfifo` also pops `sramreqfifo` entry.\n\nThe `reqfifo` entry is used to construct the TL-UL response.\nWhen the response is accepted by an upstream TL-UL host, the `reqfifo` and `rspfifo` entries are both popped.\n\n#### Readback Mode\nWhen enabled using the [`SRAM_CTRL.READBACK`](../sram_ctrl/doc/registers.md#readback) register, the `tlul_sram_byte` module is capable of reading back and checking each issued read and write.\nOn an integrity failure, for example caused by a fault injection attack, a fatal alert is raised and the alert register [`STATUS.READBACK_ERROR`](../sram_ctrl/doc/registers.md#status--readback_error) is set.\nWhen the host issues a read, the `tlul_sram_byte` module performs the read, internally stores the received data from the memory, issues a second read, and compares the values of the first and second reads.\nSimilarily, on a write, the module temporarily stores the data to write, performs the write, issues a readback, and compares the read back value to the temporarily stored write data to ensure that the data correctly got written into the memory.\n",
  "adc_ctrl": "# Analog to Digital Converter Control Interface\n\n[`adc_ctrl`](https://reports.opentitan.org/hw/ip/adc_ctrl/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/adc_ctrl/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/adc_ctrl/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/adc_ctrl/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/adc_ctrl/code.svg)\n\n# Overview\n\nThis document specifies the ADC controller IP functionality.\nThis IP block implements control and filter logic for an analog block that implements a dual ADC.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top level system.\n\n## Features\n\nThe IP block implements the following features:\n\n- Register interface to dual ADC analog block\n- Support for 2 ADC channels\n- Support for 8 filters on the values from the channels\n- Support ADCs with 10-bit output (two reserved bits in CSR)\n- Support for debounce timers on the filter output\n- Run on a slow always-on clock to enable usage while the device is sleeping\n- Low power periodic scan mode for monitoring ADC channels\n\n## Description\n\nThe ADC controller is a simple front-end to an analog block that allows filtering and debouncing of the analog signals.\n\n## Compatibility\n\nThe ADC controller programming interface is not based on any existing interface.\n",
  "sram_ctrl": "# SRAM Controller Technical Specification\n\n[`sram_ctrl/main`](https://reports.opentitan.org/hw/ip/sram_ctrl_main/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/main/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/main/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/main/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/main/code.svg)\n\n[`sram_ctrl/ret`](https://reports.opentitan.org/hw/ip/sram_ctrl_ret/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/ret/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/ret/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/ret/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sram_ctrl/ret/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the SRAM memory controller.\nThe SRAM controller is a module that is a peripheral on the chip interconnect bus, and thus follows the [Comportability Specification](../../../doc/contributing/hw/comportability/README.md).\n\n\nThe SRAM controller contains the SRAM data and address scrambling device and provides CSRs for requesting the scrambling keys and triggering the hardware initialization feature.\n\n## Features\n\n- [Lightweight scrambling mechanism](../prim/doc/prim_ram_1p_scr.md#custom-substitution-permutation-network) based on the PRINCE cipher.\n- Key request logic for the lightweight memory and address scrambling device.\n- Alert sender and checking logic for detecting bus integrity failures.\n- LFSR-based memory initialization feature.\n- Access controls to allow / disallow code execution from SRAM.\n- Security hardening when integrity error has been detected.\n- Optional memory readback mode for detecting memory integrity errors.\n",
  "prim_xilinx": "No README available.",
  "rv_timer": "# Timer HWIP Technical Specification\n\n[`rv_timer`](https://reports.opentitan.org/hw/ip/rv_timer/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/rv_timer/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rv_timer/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rv_timer/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rv_timer/code.svg)\n\n# Overview\n\nThis document specifies RISC-V Timer hardware IP functionality. This module\nconforms to the\n[Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top level\nsystem.\n\n\n## Features\n\n- 64-bit timer with 12-bit prescaler and 8-bit step register\n- Compliant with RISC-V privileged specification v1.11\n- Configurable number of timers per hart and number of harts\n\n## Description\n\nThe timer module provides a configurable number of 64-bit counters where each\ncounter increments by a step value whenever the prescaler times out. Each timer\ngenerates an interrupt if the counter reaches (or is above) a programmed\nvalue. The timer is intended to be used by the processors to check the current\ntime relative to the reset or the system power-on.\n\nIn this version, the timer doesn't consider low-power modes and\nassumes the clock is neither turned off nor changed during runtime.\n\n## Compatibility\n\nThe timer IP provides memory-mapped registers equivalent to `mtime` and `mtimecmp` which can\nbe used as the machine-mode timer registers defined in the RISC-V privileged\nspec. Additional features such as prescaler, step, and a configurable number of\ntimers and harts have been added.\n",
  "lc_ctrl": "# Life Cycle Controller Technical Specification\n\n[`lc_ctrl`](https://reports.opentitan.org/hw/ip/lc_ctrl/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/lc_ctrl/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/lc_ctrl/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/lc_ctrl/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/lc_ctrl/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the life cycle controller.\nThe life cycle controller is a module that is a peripheral on the chip interconnect bus, and thus follows the [Comportability Specification](../../../doc/contributing/hw/comportability/README.md).\nFor the high-level description of the life cycle architecture of OpenTitan, please refer to the [Device Life Cycle Architecture](../../../doc/security/specs/device_life_cycle/README.md).\nThe life cycle implementation refers to the design that encompasses all life cycle functions.\nThis touches on the functionality of the following modules, listed in no particular order:\n- The life cycle controller itself - A new peripheral\n- The key manager\n- The flash controller\n- The OTP controller\n- The reset / power controller\n- The debug infrastructure, specifically TAP isolation\n- Any other peripheral where life cycle information may alter its behavior\n\n## Features\n\nThe life cycle controller provides the following features:\n- Dedicated OTP interface to read and update the redundantly encoded device life cycle state.\n- A CSR and a JTAG interface for initiating life cycle transitions.\n- Dedicated concurrent decoding of the redundant life cycle state and broadcasting of redundantly encoded life cycle qualification signals (e.g., to enable DFT features or the main processor).\n- A token hashing and matching mechanism to guard important life cycle transitions.\n- An escalation receiver for the alert subsystem, which allows to invalidate the life cycle state as part of an escalation sequence (see also alert handler subsystem).\n\n## Prelude - Why Not Software?\n\nThere are many ways to implement life cycle functions in a design.\nThis document opts for a more hardware driven approach, although there is still significant software hand holding required.\n\nThe question must be asked then, why not make it a completely software driven approach?\nThe life cycle states can be maintained simply as OTP variables, and ROM or a subsequent software stage can be responsible for choosing all subsequent behaviors.\n\nThere are a few reasons:\n- This document strives to keep critical security functionality in hardware - either real gates or ROM.\n- This document aims to keep the ROM as simple as required and not give it too much functionality.\nSimple here refers to secure boot verification and jump.\n- There is a life cycle escalation mechanism that temporarily alters the state when security vulnerabilities are detected.\nIt is difficult to manage this kind of fast escalation in software in our working model.\nIt is more suitable in hardware.\n- Advancing life cycle state sometimes must be done in the absence of software for a variety of reasons; thus having a small piece of hardware that understands what to do is simpler than placing restrictions on the entire CPU / memory complex.\n- As can be seen from this document, the hardware additions are small and non-complicated.\n",
  "ascon": "# Overview\n\nThis document specifies the [Ascon](https://ascon.iaik.tugraz.at/) hardware IP functionality.\nAscon is a sponge-based, single pass, online Authenticated Encryption Scheme (that can also be used for hashing).\nIt was selected by [NIST as the winner](https://www.nist.gov/news-events/news/2023/02/nist-selects-lightweight-cryptography-algorithms-protect-small-devices) of the NIST lightweight cryptography competition and is soon to be standardized.\n\n\n## Features\n\nThe Ascon units supports the following features:\n\n* Authenticated encryption/decryption using either Ascon-128 (64 bit block size, 6 rounds per block update) or Ascon-128a (128 bit block size, 8 rounds per block update), whichever variant is standardized by NIST[^1], with a key and tag size of 128 bit, which leads to 128 bit security, and a state size of 320 bits.\n* Support for Hashing might be implemented at a later time.\n* First-order masking of the cipher core using domain-oriented masking (DOM) to deter side-channel analysis (SCA) is planned for the final version.\n* The latency of the Ascon permutation per 64/128 bit block is 6/8 clock cycles (unmasked) and presumably 12/16 clock cycles (DOM) for Ascon-128/Ascon-128a.\nOverall, 1 cycle is needed to absorb the data, 6/8 cycles are needed for the permutation and again 1 cycle to extract the output.\nHowever, the extraction and absorption are done simultaneously.\nThus, in total, for long messages, the latency between a corresponding plaintext-ciphertext block is 1 cycle,\nand the latency between two consecutive ciphertext/plaintext blocks is 7/9 cycles; assuming large input sizes such that initialization and tag computation are negligible.\n* Automatic as well as software-initiated reseeding of internal pseudo-random number generators (PRNGs).\nThis will be implemented in the final version.\n* Countermeasures for deterring fault injection (FI) on the control path (for more details see [Security Hardening](#security-hardening-13)).\n* Register-based data and control interface.\n* System key manager interface for optional key sideload to not expose key material to the processor and other hosts attached to the system bus interconnect.\n\nThis Ascon unit targets medium performance (~1 clock cycle per round for the unmasked implementation).\nHigh-speed, multiple rounds per clock cycles for high-bandwidth data streaming is not required.\n\n\n## Description\n\nThe Ascon unit is a cryptographic accelerator that accepts requests from the processor to encrypt or decrypt pairs of associated data A and messages M. A and M are divided into blocks, where each block is 64/128 bits, except the last block that can be potentially smaller.\nEmpty strings are allowed, where either A, M or both are empty.\nThe unit also takes a unique nonce N per each pair (A,M).\nThe encryption request outputs a ciphertext C of the same size as M, and a 128-bit tag T.\nThe decryption request checks the validity of the ciphertext with respect to the key, N and A, and returns a failure code if the ciphertext is invalid.\nThe algorithm requires that the implementation outputs a decrypted message M of the same size as M only if M is valid.\nImplementing this fully in hardware is infeasible, however, as the plaintext size is variable and would require large dedicated buffer memory.\nOur Ascon unit thus outputs the decrypted plaintext before it is verified and SW interfacing the Ascon unit must make sure not to use such plaintext if it is invalid.\n\nThe Ascon unit consists of 5 main components:\nencrypt/decrypt FSM, Ascon permutation round, the functionality of initializing or updating the internal state and extracting ciphertext (dubbed as duplex switch), the tag extractor (for releasing the tag), and tag comparator (for checking the tag validity).\n\nThe Ascon unit is attached to the chip interconnect bus as a peripheral module.\nCommunication with the processor happens through a set of control and status registers (CSRs).\nThis includes the input/output data, key, nonce, as well as status and control information.\n\n[^1]: There are two main variants: Ascon128 and Ascon 128a. Both variants use 12 rounds for initialization and finalization. They differ in the input block size and the rounds per update.\n    \"Ascon v1.2. Submission to NIST.\" [https://csrc.nist.gov/CSRC/media/Projects/lightweight-cryptography/documents/round-2/spec-doc-rnd2/ascon-spec-round2.pdf](https://csrc.nist.gov/CSRC/media/Projects/lightweight-cryptography/documents/round-2/spec-doc-rnd2/ascon-spec-round2.pdf). Accessed 21 Aug. 2023.\n    According to [https://csrc.nist.gov/csrc/media/Presentations/2023/update-on-standardization-of-ascon-family/images-media/sess-6-turan-bcm-workshop-2023.pdf](https://csrc.nist.gov/csrc/media/Presentations/2023/update-on-standardization-of-ascon-family/images-media/sess-6-turan-bcm-workshop-2023.pdf) either both or only Ascon-128 will be standardized. Further, there might be no dedicated Hash function but only a standardized XOF form.\n    Non standardized extensions like a PRF could be implemented with a marginal overhead in a future version.\n",
  "otbn": "# OpenTitan Big Number Accelerator (OTBN) Technical Specification\n\n[`otbn`](https://reports.opentitan.org/hw/ip/otbn/dv/uvm/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/otbn/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/otbn/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/otbn/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/otbn/code.svg)\n\n# Overview\n\nThis document specifies functionality of the OpenTitan Big Number Accelerator, or OTBN.\nOTBN is a coprocessor for asymmetric cryptographic operations like RSA or Elliptic Curve Cryptography (ECC).\n\nThis module conforms to the [Comportable guideline for peripheral functionality](../../../doc/contributing/hw/comportability/README.md).\nSee that document for integration overview within the broader top level system.\n\n## Features\n\n* Processor optimized for wide integer arithmetic\n* 32b wide control path with 32 32b wide registers\n* 256b wide data path with 32 256b wide registers\n* Full control-flow support with conditional branch and unconditional jump instructions, hardware loops, and hardware-managed call/return stacks.\n* Reduced, security-focused instruction set architecture for easier verification and the prevention of data leaks.\n* Built-in access to random numbers.\n\n## Description\n\nOTBN is a processor, specialized for the execution of security-sensitive asymmetric (public-key) cryptography code, such as RSA or ECC.\nSuch algorithms are dominated by wide integer arithmetic, which are supported by OTBN's 256b wide data path, registers, and instructions which operate these wide data words.\nOn the other hand, the control flow is clearly separated from the data, and reduced to a minimum to avoid data leakage.\n\nThe data OTBN processes is security-sensitive, and the processor design centers around that.\nThe design is kept as simple as possible to reduce the attack surface and aid verification and testing.\nFor example, no interrupts or exceptions are included in the design, and all instructions are designed to be executable within a single cycle.\n\nOTBN is designed as a self-contained co-processor with its own instruction and data memory, which is accessible as a bus device.\n\n## Compatibility\n\nOTBN is not designed to be compatible with other cryptographic accelerators.\nIt received some inspiration from assembly code available from the [Chromium EC project](https://chromium.googlesource.com/chromiumos/platform/ec/),\nwhich has been formally verified within the [Fiat Crypto project](http://adam.chlipala.net/papers/FiatCryptoSP19/FiatCryptoSP19.pdf).\n\n# Instruction Set\n\nOTBN is a processor with a custom instruction set.\nThe full ISA description can be found in our [ISA manual](./doc/isa.md).\nThe instruction set is split into two groups:\n\n* The **base instruction subset** operates on the 32b General Purpose Registers (GPRs).\n  Its instructions are used for the control flow of a OTBN application.\n  The base instructions are inspired by RISC-V's RV32I instruction set, but not compatible with it.\n* The **big number instruction subset** operates on 256b Wide Data Registers (WDRs).\n  Its instructions are used for data processing.\n\n## Processor State\n\n### General Purpose Registers (GPRs)\n\nOTBN has 32 General Purpose Registers (GPRs), each of which is 32b wide.\nThe GPRs are defined in line with RV32I and are mainly used for control flow.\nThey are accessed through the base instruction subset.\nGPRs aren't used by the main data path; this operates on the [Wide Data Registers](#wide-data-registers-wdrs), a separate register file, controlled by the big number instructions.\n\n<table>\n  <tr>\n    <td><code>x0</code></td>\n    <td>Zero register. Reads as 0; writes are ignored.</td>\n  </tr>\n  <tr>\n    <td><code>x1</code></td>\n<td>\n\nAccess to the [call stack](#call-stack)\n\n</td>\n  </tr>\n  <tr>\n    <td><code>x2</code> ... <code>x31</code></td>\n    <td>General purpose registers</td>\n  </tr>\n</table>\n\nNote: Currently, OTBN has no \"standard calling convention,\" and GPRs other than `x0` and `x1` can be used for any purpose.\nIf a calling convention is needed at some point, it is expected to be aligned with the RISC-V standard calling conventions, and the roles assigned to registers in that convention.\nEven without a agreed-on calling convention, software authors are encouraged to follow the RISC-V calling convention where it makes sense.\nFor example, good choices for temporary registers are `x6`, `x7`, `x28`, `x29`, `x30`, and `x31`.\n\n### Call Stack\n\nOTBN has an in-built call stack which is accessed through the `x1` GPR.\nThis is intended to be used as a return address stack, containing return addresses for the current stack of function calls.\nSee the documentation for {{#otbn-insn-ref JAL}} and {{#otbn-insn-ref JALR}} for a description of how to use it for this purpose.\n\nThe call stack has a maximum depth of 8 elements.\nEach instruction that reads from `x1` pops a single element from the stack.\nEach instruction that writes to `x1` pushes a single element onto the stack.\nAn instruction that reads from an empty stack or writes to a full stack causes a `CALL_STACK` [software error](#design-details-errors).\n\nA single instruction can both read and write to the stack.\nIn this case, the read is ordered before the write.\nProviding the stack has at least one element, this is allowed, even if the stack is full.\n\n### Control and Status Registers (CSRs)\n\nControl and Status Registers (CSRs) are 32b wide registers used for \"special\" purposes, as detailed in their description;\nthey are not related to the GPRs.\nCSRs can be accessed through dedicated instructions, {{#otbn-insn-ref CSRRS}} and {{#otbn-insn-ref CSRRW}}.\nWrites to read-only (RO) registers are ignored; they do not signal an error.\nAll read-write (RW) CSRs are set to 0 when OTBN starts an operation (when 1 is written to [`CMD.start`](doc/registers.md#cmd)).\n\n<!-- This list of CSRs is replicated in otbn_env_cov.sv, wsr.py, the\n     RTL and in rig/model.py. If editing one, edit the other four as well. -->\n<!-- BEGIN CMDGEN ./hw/ip/otbn/util/docs/md_isrs.py hw/ip/otbn/data/csr.yml -->\n<table>\n  <thead>\n    <tr>\n      <th>Number</th>\n      <th>Access</th>\n      <th>Name</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0x7C0</td>\n      <td>RW</td>\n      <td>FG0</td>\n      <td>\n        Wide arithmetic flag group 0.\n        This CSR provides access to flag group 0 used by wide integer arithmetic.\n        *FLAGS*, *FG0* and *FG1* provide different views on the same underlying bits.\n        <table>\n          <thead>\n            <tr><th>Bit</th><th>Description</th></tr>\n          </thead>\n          <tbody>\n            <tr><td>0</td><td>Carry of flag group 0</td></tr>\n            <tr><td>1</td><td>MSb of flag group 0</td></tr>\n            <tr><td>2</td><td>LSb of flag group 0</td></tr>\n            <tr><td>3</td><td>Zero of flag group 0</td></tr>\n          </tbody>\n        </table>\n      </td>\n    </tr>\n    <tr>\n      <td>0x7C1</td>\n      <td>RW</td>\n      <td>FG1</td>\n      <td>\n        Wide arithmetic flag group 1.\n        This CSR provides access to flag group 1 used by wide integer arithmetic.\n        *FLAGS*, *FG0* and *FG1* provide different views on the same underlying bits.\n        <table>\n          <thead>\n            <tr><th>Bit</th><th>Description</th></tr>\n          </thead>\n          <tbody>\n            <tr><td>0</td><td>Carry of flag group 1</td></tr>\n            <tr><td>1</td><td>MSb of flag group 1</td></tr>\n            <tr><td>2</td><td>LSb of flag group 1</td></tr>\n            <tr><td>3</td><td>Zero of flag group 1</td></tr>\n          </tbody>\n        </table>\n      </td>\n    </tr>\n    <tr>\n      <td>0x7C8</td>\n      <td>RW</td>\n      <td>FLAGS</td>\n      <td>\n        Wide arithmetic flag groups.\n        This CSR provides access to both flag groups used by wide integer arithmetic.\n        *FLAGS*, *FG0* and *FG1* provide different views on the same underlying bits.\n        <table>\n          <thead>\n            <tr><th>Bit</th><th>Description</th></tr>\n          </thead>\n          <tbody>\n            <tr><td>0</td><td>Carry of flag group 0</td></tr>\n            <tr><td>1</td><td>MSb of flag group 0</td></tr>\n            <tr><td>2</td><td>LSb of flag group 0</td></tr>\n            <tr><td>3</td><td>Zero of flag group 0</td></tr>\n            <tr><td>4</td><td>Carry of flag group 1</td></tr>\n            <tr><td>5</td><td>MSb of flag group 1</td></tr>\n            <tr><td>6</td><td>LSb of flag group 1</td></tr>\n            <tr><td>7</td><td>Zero of flag group 1</td></tr>\n          </tbody>\n        </table>\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D0</td>\n      <td>RW</td>\n      <td>MOD0</td>\n      <td>\n        Bits [31:0] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D1</td>\n      <td>RW</td>\n      <td>MOD1</td>\n      <td>\n        Bits [63:32] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D2</td>\n      <td>RW</td>\n      <td>MOD2</td>\n      <td>\n        Bits [95:64] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D3</td>\n      <td>RW</td>\n      <td>MOD3</td>\n      <td>\n        Bits [127:96] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D4</td>\n      <td>RW</td>\n      <td>MOD4</td>\n      <td>\n        Bits [159:128] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D5</td>\n      <td>RW</td>\n      <td>MOD5</td>\n      <td>\n        Bits [191:160] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D6</td>\n      <td>RW</td>\n      <td>MOD6</td>\n      <td>\n        Bits [223:192] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D7</td>\n      <td>RW</td>\n      <td>MOD7</td>\n      <td>\n        Bits [255:224] of the modulus operand, used in the {{#otbn-insn-ref BN.ADDM}}/{{#otbn-insn-ref BN.SUBM}} instructions.\n        This CSR is mapped to the MOD WSR.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7D8</td>\n      <td>RW</td>\n      <td>RND_PREFETCH</td>\n      <td>\n        Write to this CSR to begin a request to fill the RND cache.\n        Always reads as 0.\n      </td>\n    </tr>\n    <tr>\n      <td>0xFC0</td>\n      <td>RO</td>\n      <td>RND</td>\n      <td>\n        An AIS31-compliant class PTG.3 random number with guaranteed entropy and forward and backward secrecy.\n        Primarily intended to be used for key generation.\n        <br>\n        The number is sourced from the EDN via a single-entry cache.\n        Reads when the cache is empty will cause OTBN to be stalled until a new random number is fetched from the EDN.\n      </td>\n    </tr>\n    <tr>\n      <td>0xFC1</td>\n      <td>RO</td>\n      <td>URND</td>\n      <td>\n        A random number without guaranteed secrecy properties or specific statistical properties.\n        Intended for use in masking and blinding schemes.\n        Use RND for high-quality randomness.\n        <br>\n        The number is sourced from an local PRNG.\n        Reads never stall.\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<!-- END CMDGEN -->\n\n### Wide Data Registers (WDRs)\n\nIn addition to the 32b wide GPRs, OTBN has a second \"wide\" register file, which is used by the big number instruction subset.\nThis register file consists of NWDR = 32 Wide Data Registers (WDRs).\nEach WDR is WLEN = 256b wide.\n\nWide Data Registers (WDRs) and the 32b General Purpose Registers (GPRs) are separate register files.\nThey are only accessible through their respective instruction subset:\nGPRs are accessible from the base instruction subset, and WDRs are accessible from the big number instruction subset (`BN` instructions).\n\n| Register |\n|----------|\n| w0       |\n| w1       |\n| ...      |\n| w31      |\n\n### Wide Special Purpose Registers (WSRs)\n\nOTBN has 256b Wide Special purpose Registers (WSRs).\nThese are analogous to the 32b CSRs, but are used by big number instructions.\nThey can be accessed with the {{#otbn-insn-ref BN.WSRR}} and {{#otbn-insn-ref BN.WSRW}} instructions.\nWrites to read-only (RO) registers are ignored; they do not signal an error.\nAll read-write (RW) WSRs are set to 0 when OTBN starts an operation (when 1 is written to [`CMD.start`](doc/registers.md#cmd)).\n\n<!-- This list of WSRs is replicated in otbn_env_cov.sv, wsr.py, the\n     RTL and in rig/model.py. If editing one, edit the other four as well. -->\n<!-- BEGIN CMDGEN ./hw/ip/otbn/util/docs/md_isrs.py --add-anchors hw/ip/otbn/data/wsr.yml -->\n<table>\n  <thead>\n    <tr>\n      <th>Number</th>\n      <th>Access</th>\n      <th>Name</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0x0</td>\n      <td>RW</td>\n      <td><a name=\"mod\">MOD</a></td>\n      <td>\n        The modulus used by the {{#otbn-insn-ref BN.ADDM}} and {{#otbn-insn-ref BN.SUBM}} instructions.\n        This WSR is also visible as CSRs `MOD0` through to `MOD7`.\n      </td>\n    </tr>\n    <tr>\n      <td>0x1</td>\n      <td>RO</td>\n      <td><a name=\"rnd\">RND</a></td>\n      <td>\n        An AIS31-compliant class PTG.3 random number with guaranteed entropy and forward and backward secrecy.\n        Primarily intended to be used for key generation.\n        <br>\n        The number is sourced from the EDN via a single-entry cache.\n        Reads when the cache is empty will cause OTBN to be stalled until a new random number is fetched from the EDN.\n      </td>\n    </tr>\n    <tr>\n      <td>0x2</td>\n      <td>RO</td>\n      <td><a name=\"urnd\">URND</a></td>\n      <td>\n        A random number without guaranteed secrecy properties or specific statistical properties.\n        Intended for use in masking and blinding schemes.\n        Use RND for high-quality randomness.\n        <br>\n        The number is sourced from an local PRNG.\n        Reads never stall.\n      </td>\n    </tr>\n    <tr>\n      <td>0x3</td>\n      <td>RW</td>\n      <td><a name=\"acc\">ACC</a></td>\n      <td>\n        The accumulator register used by the {{#otbn-insn-ref BN.MULQACC}} instruction.\n      </td>\n    </tr>\n    <tr>\n      <td>0x4</td>\n      <td>RO</td>\n      <td><a name=\"key-s0-l\">KEY_S0_L</a></td>\n      <td>\n        Bits [255:0] of share 0 of the 384b OTBN sideload key provided by the [Key Manager](../keymgr/README.md).\n        <br>\n        A `KEY_INVALID` software error is raised on read if the Key Manager has not provided a valid key.\n      </td>\n    </tr>\n    <tr>\n      <td>0x5</td>\n      <td>RO</td>\n      <td><a name=\"key-s0-h\">KEY_S0_H</a></td>\n      <td>\n        Bits [255:128] of this register are always zero.\n        Bits [127:0] contain bits [383:256] of share 0 of the 384b OTBN sideload key provided by the [Key Manager](../keymgr/README.md).\n        <br>\n        A `KEY_INVALID` software error is raised on read if the Key Manager has not provided a valid key.\n      </td>\n    </tr>\n    <tr>\n      <td>0x6</td>\n      <td>RO</td>\n      <td><a name=\"key-s1-l\">KEY_S1_L</a></td>\n      <td>\n        Bits [255:0] of share 1 of the 384b OTBN sideload key provided by the [Key Manager](../keymgr/README.md).\n        <br>\n        A `KEY_INVALID` software error is raised on read if the Key Manager has not provided a valid key.\n      </td>\n    </tr>\n    <tr>\n      <td>0x7</td>\n      <td>RO</td>\n      <td><a name=\"key-s1-h\">KEY_S1_H</a></td>\n      <td>\n        Bits [255:128] of this register are always zero.\n        Bits [127:0] contain bits [383:256] of share 1 of the 384b OTBN sideload key provided by the [Key Manager](../keymgr/README.md).\n        <br>\n        A `KEY_INVALID` software error is raised on read if the Key Manager has not provided a valid key.\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<!-- END CMDGEN -->\n\n### Flags\n\nIn addition to the wide register file, OTBN maintains global state in two groups of flags for the use by wide integer operations.\nFlag groups are named Flag Group 0 (`FG0`), and Flag Group 1 (`FG1`).\nEach group consists of four flags.\nEach flag is a single bit.\n\n- `C` (Carry flag).\n  Set to 1 an overflow occurred in the last arithmetic instruction.\n\n- `M` (MSb flag)\n  The most significant bit of the result of the last arithmetic or shift instruction.\n\n- `L` (LSb flag).\n  The least significant bit of the result of the last arithmetic or shift instruction.\n\n- `Z` (Zero Flag)\n  Set to 1 if the result of the last operation was zero; otherwise 0.\n\nThe `M`, `L`, and `Z` flags are determined based on the result of the operation as it is written back into the result register, without considering the overflow bit.\n\n### Loop Stack\n\nOTBN has two instructions for hardware-assisted loops: {{#otbn-insn-ref LOOP}} and {{#otbn-insn-ref LOOPI}}.\nBoth use the same state for tracking control flow.\nThis is a stack of tuples containing a loop count, start address and end address.\nThe stack has a maximum depth of eight and the top of the stack is the current loop.\n\n# Security Features\n\nOTBN is a security co-processor.\nIt contains various security features and is hardened against side-channel analysis and fault injection attacks.\nThe following sections describe the high-level security features of OTBN.\nRefer to the [Design Details](#design-details) section for a more in-depth description.\n\n## Data Integrity Protection\n\nOTBN's data integrity protection is designed to protect the data stored and processed within OTBN from modifications through physical attacks.\n\nData in OTBN travels along a data path which includes the data memory (DMEM), the load-store-unit (LSU), the register files (GPR and WDR), and the execution units.\nWhenever possible, data transmitted or stored within OTBN is protected with an integrity protection code which guarantees the detection of at least three modified bits per 32 bit word.\nAdditionally, instructions and data stored in the instruction and data memory, respectively, are scrambled with a lightweight, non-cryptographically-secure cipher.\n\nRefer to the [Data Integrity Protection](./doc/theory_of_operation.md#data-integrity-protection) section for details of how the data integrity protections are implemented.\n\n## Secure Wipe\n\nOTBN provides a mechanism to securely wipe all state it stores, including the instruction memory.\n\nThe full secure wipe mechanism is split into three parts:\n- [Data memory secure wipe](./doc/theory_of_operation.md#data-memory-dmem-secure-wipe)\n- [Instruction memory secure wipe](./doc/theory_of_operation.md#instruction-memory-imem-secure-wipe)\n- [Internal state secure wipe](./doc/theory_of_operation.md#internal-state-secure-wipe)\n\nA secure wipe is performed automatically in certain situations, or can be requested manually by the host software.\nThe full secure wipe is automatically initiated as a local reaction to a fatal error.\nIn addition, it can be triggered by the [Life Cycle Controller](../lc_ctrl/README.md) before RMA entry using the `lc_rma_req/ack` interface.\nIn both cases OTBN enters the locked state afterwards and needs to be reset.\nA secure wipe of only the internal state is performed after reset, whenever an OTBN operation is complete, and after a recoverable error.\nFinally, host software can manually trigger the data memory and instruction memory secure wipe operations by issuing an appropriate\n[command](./doc/theory_of_operation.md#operations-and-commands).\n\nRefer to the [Secure Wipe](./doc/theory_of_operation.md#secure-wipe) section for implementation details.\n\n## Instruction Counter\n\nIn order to detect and mitigate fault injection attacks on the OTBN, the host CPU can read the number of executed instructions from [`INSN_CNT`](doc/registers.md#insn_cnt) and verify whether it matches the expectation.\nThe host CPU can clear the instruction counter when OTBN is not running.\nWriting any value to [`INSN_CNT`](doc/registers.md#insn_cnt) clears this register to zero.\nWrite attempts while OTBN is running are ignored.\n\n## Key Sideloading\n\nOTBN software can make use of a single 384b wide key provided by the [Key Manager](../keymgr/README.md), which is made available in two shares.\nThe key is passed through a dedicated connection between the Key Manager and OTBN to avoid exposing it to other components.\nSoftware can access the first share of the key through the [`KEY_S0_L`](#key-s0-l) and [`KEY_S0_H`](#key-s0-h) WSRs, and the second share of the key through the [`KEY_S1_L`](#key-s1-l) and [`KEY_S1_H`](#key-s1-h) WSRs.\n\nIt is up to host software to configure the Key Manager so that it provides the right key to OTBN at the start of the operation, and to remove the key again once the operation on OTBN has completed.\nA `KEY_INVALID` software error is raised if OTBN software accesses any of the `KEY_*` WSRs when the Key Manager has not presented a key.\n\n## Blanking\n\nTo reduce side channel leakage OTBN employs a blanking technique on certain control and data paths.\nWhen a path is blanked it is forced to 0 (by ANDing the path with a blanking signal) preventing sensitive data bits producing a power signature via that path where that path isn't needed for the current instruction.\n\nBlanking controls all come directly from flops to prevent glitches in decode logic reducing the effectiveness of the blanking.\nThese control signals are determined in the [prefetch stage](#instruction-prefetch) via pre-decode logic.\nFull decoding is still performed in the execution stage with the full decode results checked against the pre-decode blanking control.\nIf the full decode disagrees with the pre-decode OTBN raises a `BAD_INTERNAL_STATE` fatal error.\n\nBlanking is applied in the following locations:\n\n* Read path from the bignum, CSR and WDR register files.\n  This is achieved with a one-hot mux with a two-level AND-OR structure.\n* Write data into the bignum, CSR and WDR register files.\n  Blanking is done separately for each register (as opposed to once on incoming write data that fans out to each register).\n* All relevant data paths within the bignum ALU and MAC.\n  Data paths not required for the instruction being executed are blanked.\n\nNote there is no blanking on the base side (save for the CSRs as these provide access to WDRs such as ACC).\n\n# References\n\n<a name=\"ref-chen08\">[CHEN08]</a> L. Chen, \"Hsiao-Code Check Matrices and Recursively Balanced Matrices,\" arXiv:0803.1217 [cs], Mar. 2008 [Online]. Available: https://arxiv.org/abs/0803.1217\n\n<a name=\"ref-symbiotic21\">[SYMBIOTIC21]</a> RISC-V Bitmanip Extension v0.93 Available: https://github.com/riscv/riscv-bitmanip/releases/download/v0.93/bitmanip-0.93.pdf\n",
  "entropy_src": "# ENTROPY_SRC HWIP Technical Specification\n\n[`entropy_src`](https://reports.opentitan.org/hw/ip/entropy_src/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/entropy_src/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/entropy_src/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/entropy_src/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/entropy_src/code.svg)\n\n# Overview\n\nThis document specifies ENTROPY_SRC hardware IP functionality.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\n\n## Features\n\n- This revision provides an interface to an external physical random noise generator (also referred to as a physical true random number generator or PTRNG).\nThe PTRNG external source is a physical true random noise source.\nA noise source and its relation to an entropy source are defined by [SP 800-90B.](https://csrc.nist.gov/publications/detail/sp/800-90b/final)\n- A set of registers is provided for firmware to obtain entropy bits.\n- Interrupts are supported:\n  - Entropy bits are available for firmware consumption.\n  - The internal health tests have detected a test failure.\n  - An internal FIFO error has occurred.\n- Two health checks that are defined by SP 800-90B are performed by this revision: Repetition Count and Adaptive Proportion tests.\n- Two additional hardware health checks are performed by this revision: Bucket and Markov tests.\n- Firmware-defined (mailbox-based) and vendor-defined health checks are also supported.\n- A health check failure alert is supported by this revision.\n\n## Description\n\nThis IP block provides an entropy source that is capable of using a PTRNG (Physical True Random Number Generator) noise source to generate random values in a manner that is compliant both with FIPS (though NIST SP 800-90B) and CC (AIS31) recommendations.\n\nAt a high-level, the ENTROPY_SRC block, when enabled, will continuously collect entropy bits from the PTRNG noise source, perform health tests on the collected entropy bits, pack them, send them through a conditioning unit, and finally store them into a FIFO.\nThe content of this FIFO can either be sent out through a hardware interface or alternatively (but not simultaneously) read by firmware over the TL-UL bus.\nThe random values generated by the ENTROPY_SRC block serve as non-deterministic seeds for the CSRNG block.\nThe outputs of the CSRNG are then used either directly by firmware or are distributed to other hardware blocks through the Entropy Distribution Network.\n\nIn the terms of AIS31 classes, this block is meant to satisfy the requirements for a PTG.2 class physical entropy source, with \"internal\" entropy (an AIS31 term, meaning the min-entropy as measured just *before the output pins*) exceeding 0.997 entropy-bits/output-bit.\nIn NIST terms, this block satisfies the requirements for a \"full-entropy\" source, which requires even smaller deviations from ideal entropy, at the level of less than one part in 2<sup>64</sup>.\n\nThe raw noise bits from the PTRNG noise source (external to this block) are subjected to a sequence of health-checks to screen the raw signals for statistical defects which would cause any significant deviations from ideal entropy at the output of the conditioning block.\nThese tests include:\n- The Repetition Count test, which screens for stuck-bits, or a complete failure of the PTRNG noise source,\n- The Adaptive Proportion test, which screens for statistical bias in the number of 1's or 0's output by the noise source,\n- The \"Bucket Test\", which looks for correlations between the individual noise channels that the external noise source concatenates together to produce the raw noise sequence,\n- The \"Markov Test\", which looks for unexpected first-order temporal correlations between bits output by the individual noise channels,\n- The \"Mailbox Test\", in which raw-noise data is transferred to firmware in contiguous blocks, so that firmware can perform custom tests, and signal a failure through the same path as the other tests, and\n- Optional Vendor Specific tests, which allow silicon creators to extend the health checks by adding a top-level block external to this IP.\n\nThe Repetition Count and Adaptive Proportion test are specifically recommended by SP 800-90B, and are implemented in accordance with those recommendations.\nIn FIPS/CC compliant mode, all checks except the Repetition Count test are performed on a fixed window of data of configurable size, by default consisting of 2048 bits each.\nPer the definition in SP 800-90B, the Repetition Count test does not operate on a fixed window.\nThe repetition count test fails if any sequence of bits continuously asserts the same value for too many samples, as determined by the programmable threshold, regardless of whether that sequence crosses any window boundaries.\nThe thresholds for these tests should be chosen to achieve a low false-positive rate (&alpha;) given a conservative estimate of the manufacturing tolerances of the PTRNG noise source.\nThe combined choice of threshold and window size then determine the false-negative rate (&beta;), or the probability of missing statistical defects at any particular magnitude.\n\nWhen the IP is disabled by clearing the [`MODULE_ENABLE`](./doc/registers.md#MODULE_ENABLE) register, all health checks are disabled and all counters internal to the health checks are reset.\n\nWhen operating in FIPS/CC compliant mode, the raw outputs of the PTRNG noise source are passed through a conditioning function based on a suitable secure hash function (SHA-3) which has been vetted by NIST to meet the stringent requirements for a full-entropy source.\nIn order to compensate for the fact our tests (like *all* realistic statistical tests) have finite resolution for detecting defects, we conservatively use 2048 bits of PTRNG noise source to construct each 384 bit conditioned entropy sample by default.\nThe effectively used number of bits is equal to the configured health test window size.\nWhen passed through the conditioning block, the resultant entropy stream will be full entropy unless the PTRNG noise source has encountered some statistical defect serious enough to reduce the raw min-entropy to a level below 0.375 bits of entropy per output bit.\nWe choose this level as our definition of \"non-tolerable statistical defects\" for the purposes of evaluating this system under AIS31.\nGiven this definition of \"non-tolerable defects\", the health-checks as implemented for this block will almost certainly detect any of the previously mentioned defects in a single iteration of the health checks (i.e. such serious defects will be detected with very low &beta;).\n\nIn addition to the brief, low-latency health checks, various long-term statistics are accumulated in registers for additional diagnostic purposes or for in-depth analysis.\n\nThere are two modes in which entropy bits are delivered, boot-time / bypass mode and FIPS/CC compliant mode.\nBoot-time / bypass mode will deliver bits sooner for specific on-boot obfuscation applications, though the bits may not yet have been subjected to the same level of startup health checks required for FIPS or CC compliance.\n\nIn boot-time / bypass mode health checks only operate on a window of 384 bits.\nThe boot-time / bypass mode health checks are the same as the FIPS/CC health-checks, though with different thresholds.\nThey are sensitive to the same types of statistical defects, though at reduced statistical resolution.\nWith suitable thresholds, the boot-time health checks can be operate both with low false-alarm rates (low &alpha;), while still confirming with low &beta; that the total entropy of the first seed contains at least 80 bits of total entropy.\nDuring start up the initial 384 bits are held in a buffer until the boot-time start-up health checks are performed.\nStoring the seed in this buffer, allows this seed to released to the CSRNG immediately after the entropy has been confirmed.\n\nBoot-time / bypass mode also has the feature that it bypasses the SHA conditioning function, as only 384 bits are used in the initial boot-time seed.\n\nFor maximal flexibility in normal operation, the conditioning function can also be implemented by firmware.\nWhen this firmware conditioning feature is activated, data read directly out of the noise source can be re-inserted into the entropy pipeline via a TL-UL register after it has been processed by firmware.\nIt should be noted that this firmware algorithm must be vetted by NIST to satisfy the requirements for a full-entropy source.\nThis feature can also be disabled for security purposes, either by locking the feature via the [`REGWEN`](./doc/registers.md#regwen) register at boot, or by a write to one-time programmable (OTP) memory.\n\n## Compatibility\nThis IP block does not have any direct hardware compatibility requirements.\nHowever, the general design of this block follows the overall NIST recommendations, as described by SP 800-90B.\n",
  "rv_dm": "# RISC-V Debug System Wrapper Technical Specification\n\n[`rv_dm`](https://reports.opentitan.org/hw/ip/rv_dm/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/rv_dm/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rv_dm/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rv_dm/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rv_dm/code.svg)\n\n# Overview\n\nThis document specifies the RISC-V Debug System wrapper functionality.\n\n## Features\n\nThe debug system follows the execution-based debug approach described in the [RISC-V Debug Specification 0.13.2](https://github.com/riscv/riscv-debug-spec/raw/4e0bb0fc2d843473db2356623792c6b7603b94d4/riscv-debug-release.pdf) and provides the following features.\n\n- JTAG Test Access Port (TAP)\n- Run-control debug features (in cooperation with the CPU core), including breakpoints, single-stepping through code, and reading core registers\n- System Bus Access (SBA): Access to arbitrary bus-attached peripherals through JTAG\n- Compatible with RISC-V Debug Specification 0.13-compliant debug software, including OpenOCD and GDB\n- TileLink Uncached Light (TL-UL) bus interfaces\n- Late debug enable mechanism in DEV life cycle state\n\n## Description\n\nThis module provides a RISC-V Debug Specification-compliant debug system with TileLink Uncached Light bus interfaces.\nThe main functionality is provided by the [PULP RISC-V Debug System](https://github.com/pulp-platform/riscv-dbg), which is instantiated by this module.\nAll bus interfaces are converted into TL-UL.\n\nSee the [PULP RISC-V Debug System Documentation](https://github.com/lowRISC/opentitan/blob/master/hw/vendor/pulp_riscv_dbg/doc/debug-system.md) for a full list of features and further design documentation.\nThis document only describes the additional logic provided on top of the PULP RISC-V Debug System.\n\n## Compatibility\n\nThe debug system is compliant with the [RISC-V Debug Specification 0.13.2](https://github.com/riscv/riscv-debug-spec/raw/4e0bb0fc2d843473db2356623792c6b7603b94d4/riscv-debug-release.pdf).\n",
  "prim": "# lowRISC Hardware Primitives\n\n[`prim_alert`](https://reports.opentitan.org/hw/ip/prim/dv/prim_alert/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/prim_alert/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_alert/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_alert/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_alert/code.svg)\n\n[`prim_esc`](https://reports.opentitan.org/hw/ip/prim/dv/prim_esc/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/prim_esc/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_esc/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_esc/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_esc/code.svg)\n\n[`prim_lfsr`](https://reports.opentitan.org/hw/ip/prim/dv/prim_lfsr/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/prim_lfsr/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_lfsr/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_lfsr/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_lfsr/code.svg)\n\n[`prim_present`](https://reports.opentitan.org/hw/ip/prim/dv/prim_lfsr/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/prim_present/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_present/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_present/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_present/code.svg)\n\n[`prim_prince`](https://reports.opentitan.org/hw/ip/prim/dv/prim_lfsr/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/prim_prince/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_prince/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_prince/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/prim_prince/code.svg)\n\n## Concepts\n\nThis directory contains basic building blocks to create a hardware design,\ncalled primitives. A primitive is described by its name, and has a well-defined\nlist of ports and parameters.\n\nUnder the hood, primitives are slightly special, as they can have multiple\nimplementations. In contrast to many other modules in a hardware design,\nprimitives must often be implemented in technology-dependent ways. For example,\na clock multiplexer for a Xilinx FPGA is implemented differently than one for\na specific ASIC technology.\n\nNot all primitives need to have multiple implementations.\n\n* Primitives with a single, generic, implementation are normal SystemVerilog\n  modules inside the `hw/ip/prim/rtl` directory. We call these primitives\n  \"technology-independent primitives\".\n* Primitives with multiple implementations have only a FuseSoC core file in the\n  `hw/ip/prim` directory. The actual implementations are in \"technology\n  libraries\". We call these primitives \"technology-dependent primitives\".\n\n### Abstract primitives\n\nAbstract primitives are wrappers around technology-dependent implementations of\nprimitives, with the ability to select a specific implementation if needed.\n\nIn more technical terms, abstract primitives are SystemVerilog modules. The\nexample below shows one.\n\n```systemverilog\n`ifndef PRIM_DEFAULT_IMPL\n  `define PRIM_DEFAULT_IMPL prim_pkg::ImplGeneric\n`endif\n\nmodule prim_pad_wrapper\n#(\n  parameter int unsigned AttrDw = 6\n) (\n  inout wire         inout_io, // bidirectional pad\n  output logic       in_o,     // input data\n  input              out_i,    // output data\n  input              oe_i,     // output enable\n  // additional attributes {drive strength, keeper, pull-up, pull-down, open-drain, invert}\n  input [AttrDw-1:0] attr_i\n);\n  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL;\n\n  if (Impl == prim_pkg::ImplGeneric) begin : gen_generic\n    prim_generic_pad_wrapper u_impl_generic (\n      .*\n    );\n  end else if (Impl == prim_pkg::ImplXilinx) begin : gen_xilinx\n    prim_xilinx_pad_wrapper u_impl_xilinx (\n      .*\n    );\n  end else begin : gen_failure\n    // TODO: Find code that works across tools and causes a compile failure\n  end\n\nendmodule\n```\n\nAs seen from the source code snippet, abstract primitives have the following\nproperties:\n\n- They have an `Impl` parameter which can be set to choose a specific\n  implementation of the primitive.\n- The `Impl` parameter is set to a system-wide default determined by the\n  `PRIM_DEFAULT_IMPL` define.\n- All ports and parameters of the abstract primitive are forwarded to the\n  implementations.\n\n### Technology libraries\n\nTechnology libraries collect implementations of primitives.\n\nAt least one technology library must exist: the `generic` technology library,\nwhich contains a pure-SystemVerilog implementation of the functionality. This\nlibrary is commonly used for simulations and as functional reference. The\n`generic` technology library is contained in the `hw/ip/prim_generic` directory.\n\nIn addition to the implementation in the `generic` library, primitives may be\nimplemented by as many other libraries as needed.\n\nTechnology libraries are referenced by their name.\n\n### Technology library discovery\n\nIn many cases, technology libraries contain vendor-specific code which cannot be\nshared widely or openly. Therefore, a FuseSoC looks for available technology\nlibraries at build time, and makes all libraries it finds available.\n\nThe discovery is performed based on the agreed-on naming scheme for primitives.\n\n- FuseSoC scans all libraries (e.g. as specified by its `--cores-root` command\n  line argument) for cores.\n- All cores with a name matching `lowrisc:prim_TECHLIBNAME:PRIMNAME`\n  are considered. `TECHLIBNAME` is then added to the list of technology\n  libraries.\n\nAfter the discovery process has completed, a script (`primgen`) creates\n- an abstract primitive (see above), and\n- an entry in the `prim_pkg` package in the form of `prim_pkg::ImplTechlibname`\n  to identify the technology library by its name.\n\n## User Guide\n\n### Use primitives\n\nPrimitives are normal SystemVerilog modules, and can be used as usual:\n* instantiate it like a normal SystemVerilog module, and\n* add a dependency in the FuseSoC core file.\n\nTechnology-dependent primitives have an additional parameter called `Impl`.\nSet this parameter to use a specific implementation of the primitive for this\nspecific instance. For example:\n\n```systemverilog\nprim_ram_2p #(\n  .Width (TotalWidth),\n  .Depth (Depth),\n  // Force the use of the tsmc40lp technology library for this instance, instead\n  // of using the build-time default.\n  .Impl(prim_pkg::ImplTsmc40lp)\n) u_mem (\n  .clk_a_i    (clk_i),\n  ...\n)\n```\n\n\n### Set the default technology library\n\nIf no specific technology library is chosen for an instantiated primitive the\ndefault library is used. The SystemVerilog define `PRIM_DEFAULT_IMPL` can be\nused to set the default for the whole design. Set this define to one of the enum\nvalues in `prim_pkg.sv` in the form `prim_pkg::ImplTechlibname`. `Techlibname`\nis the capitalized name of the technology library.\n\nIn the top-level FuseSoC core file the default technology library can be chosen\nlike this:\n\n```yaml\n# my_toplevel.core\n\n# Declare filesets and other things (omitted)\n\nparameters:\n  # Make the parameter known to FuseSoC to enable overrides from the\n  # command line. If not overwritten, use the generic technology library.\n  PRIM_DEFAULT_IMPL:\n    datatype: str\n    paramtype: vlogdefine\n    description: Primitives implementation to use, e.g. \"prim_pkg::ImplGeneric\".\n    default: prim_pkg::ImplGeneric\n\ntargets:\n  fpga_synthesis:\n    filesets:\n      - my_rtl_files\n    parameters:\n      # Use the xilinx technology library for this target by default.\n      - PRIM_DEFAULT_IMPL=prim_pkg::ImplXilinx\n    toplevel: my_toplevel\n```\n\n\n### Create a technology library\n\nTo create a technology library follow these steps:\n\n- Choose a name for the new technology library. Names are all lower-case.\n  To ease sharing of technology libraries it is encouraged to pick a very\n  specific name, e.g. `tsmc40lp`, and not `asic`.\n- Copy the `prim_generic` folder into an arbitrary location (can be outside\n  of this repository). Name the folder `prim_YOURLIBRARYNAME`.\n- Replace the word `generic` everywhere with the name of your technology\n  library. This includes\n  - file and directory names (e.g. `prim_generic_ram1p.sv` becomes\n    `prim_tsmc40lp_ram1p.sv`),\n  - module names (e.g. `prim_generic_ram1p` becomes `prim_tsmc40lp_ram1p`), and\n  - all other references (grep for it!).\n- Implement all primitives. Replace the module body of the generic\n  implementation with a technology-specific implementation as needed. Do *not*\n  modify the list of ports or parameters in any way!\n\n## Implementation details\n\nTechnology-dependent primitives are implemented as a FuseSoC generator. The\ncore of the primitive (e.g. `lowrisc:prim:rom` in `prim/prim_rom.core`) calls\na FuseSoC generator. This generator is the script `util/primgen.py`. As input,\nthe script receives a list of all cores found by FuseSoC anywhere in its search\npath. The script then looks through the cores FuseSoC discovered and extracts\na list of technology libraries out of it. It then goes on to create the\nabstract primitive (copying over the list of parameters and ports from the\ngeneric implementation), and an associated core file, which depends on all\ntechnology-dependent libraries that were found.\n",
  "otp_ctrl": "# OTP Controller Technical Specification\n\n[`otp_ctrl`](https://reports.opentitan.org/hw/ip/otp_ctrl/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/otp_ctrl/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/otp_ctrl/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/otp_ctrl/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/otp_ctrl/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the one time programmable (OTP) memory controller.\nThe OTP controller is a module that is a peripheral on the chip interconnect bus, and thus follows the [Comportability Specification](../../../doc/contributing/hw/comportability/README.md).\n\nThe OTP is a module that provides a device with one-time-programming functionality.\nThe result of this programming is non-volatile, and unlike flash, cannot be reversed.\nThe OTP functionality is constructed through an open-source OTP controller and a proprietary OTP IP.\n\nThe OTP controller provides:\n- An open-source abstraction interface that software can use to interact with a proprietary OTP block underneath.\n- An open-source abstraction interface that hardware components (for example [life cycle controller](../lc_ctrl/README.md) and [key manager](../keymgr/README.md)) can use to interact with a proprietary OTP block underneath.\n- High level logical security protection, such as integrity checks and scrambling of sensitive content.\n- Software isolation for when OTP contents are readable and programmable.\n\nThe proprietary OTP IP provides:\n- Reliable, non-volatile storage.\n- Technology-specific redundancy or error correction mechanisms.\n- Physical defensive features such as SCA and FI resistance.\n- Visual and electrical probing resistance.\n\nTogether, the OTP controller and IP provide secure one-time-programming functionality that is used throughout the life cycle (LC) of a device.\n\n## Features\n\n- Multiple logical partitions of the underlying OTP IP\n  - Each partition is lockable and integrity checked\n  - Integrity digests are stored alongside each logical bank\n- Periodic / persistent checks of OTP values\n  - Periodic checks of shadowed content vs digests\n  - Periodic checks of OTP stored content and shadowed content\n  - Persistent checks for immediate errors\n- Separate life cycle partition and interface to life cycle controller\n  - Supports life cycle functions, but cannot be integrity locked\n- Lightweight scrambling of secret OTP partition using a global netlist constant\n- Lightweight ephemeral key derivation function for RAM scrambling mechanisms\n- Lightweight key derivation function for FLASH scrambling mechanism\n\n## OTP Controller Overview\n\nThe functionality of OTP is split into an open-source and a closed-source part, with a clearly defined boundary in between, as illustrated in the simplified high-level block diagram below.\n\n![OTP Controller Overview](./doc/otp_ctrl_overview.svg)\n\nIt is the task of the open-source controller to provide a common, non-technology specific interface to OTP users with a common register interface and a clearly defined I/O interface to hardware.\nThe open-source controller implements logical isolation and partitioning of OTP storage that enables users to separate different functions of the OTP into \"partitions\" with different properties.\nFinally, the open-source controller provides a high level of security for specific partitions by provisioning integrity digests for each partition, and scrambling of partitions where required.\n\nThe proprietary IP on the other hand translates a common access interface to the technology-specific OTP interface, both for functional and debug accesses (for example register accesses to the macro-internal control structure).\n\nThis split implies that every proprietary OTP IP must implement a translation layer from a standardized OpenTitan interface to the module underneath.\nIt also implies that no matter how the OTP storage or word size may change underneath, the open-source controller must present a consistent and coherent software and hardware interface.\nThis standardized interface is defined further below, and the wrapper leverages the same [technology primitive mechanism](../prim/README.md) that is employed in other parts of OpenTitan in order to wrap and abstract technology-specific macros (such as memories and clocking cells) that are potentially closed-source.\n\nIn order to enable simulation and FPGA emulation of the OTP controller even without access to the proprietary OTP IP, a generalized and synthesizable model of the OTP IP is provided in the form of a [generic technology primitive](https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim_generic/rtl/prim_generic_otp.sv).\n",
  "prim_generic": "No README available.",
  "sysrst_ctrl": "# System Reset Control Technical Specification\n\n[`sysrst_ctrl`](https://reports.opentitan.org/hw/ip/sysrst_ctrl/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/sysrst_ctrl/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sysrst_ctrl/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sysrst_ctrl/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/sysrst_ctrl/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the System Reset Controller (`sysrst_ctrl`) that provides programmable hardware-level responses to trusted IOs and basic board-level reset sequencing capabilities.\nThese capabilities include keyboard and button combination-triggered actions, reset stretching for system-level reset signals, and internal reset / wakeup requests that go to the OpenTitan reset and power manager blocks.\nThis module conforms to the [Comportable guideline for peripheral functionality](../../../doc/contributing/hw/comportability/README.md).\nSee that document for integration overview within the broader top level system.\n\n## Features\n\nThe IP block implements the following features:\n\n- Always-on: uses the always-on power and clock domain\n- EC reset pulse duration control and stretching\n- Keyboard and button combination (combo) triggered action\n- AC_present can trigger interrupt\n- Configuration registers can be set and locked until the next chip reset\n- Pin output override\n\n## Description\n\nThe `sysrst_ctrl` logic is very simple.\nIt looks up the configuration registers to decide how long the EC reset pulse duration and how long the key presses should be.\nAlso what actions to take (e.g. Interrupt, EC reset, OpenTitan reset request, disconnect the battery from the power tree).\n\n## Compatibility\n\nThe configuration programming interface is not based on any existing interface.\n",
  "spi_host": "# SPI_HOST HWIP Technical Specification\n\n[`spi_host`](https://reports.opentitan.org/hw/ip/spi_host/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/spi_host/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/spi_host/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/spi_host/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/spi_host/code.svg)\n\n# Overview\n\nThis document specifies SPI_HOST hardware IP (HWIP) functionality.\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top-level system.\n\n## Features\n\n- Hardware control for remote devices using the Serial Peripheral Interface (SPI)\n- Primarily designed for serial NOR flash devices such as the [Winbond W25Q01JV](https://www.winbond.com/resource-files/W25Q01JV%20SPI%20RevB%2011132019.pdf)\n- Number of chip select lines controlled by `NumCS` parameter\n- Support for Standard SPI, Dual SPI or Quad SPI commands\n  - Signals SD[0] through SD[3] are intended to connect to lines IO<sub>0</sub> through IO<sub>3</sub> respectively, on the target device.\n  - Signal SD[0] may also be identified as \"MOSI\" by other SPI Hosts, while SD[1] is commonly referred to as \"MISO\"\n- RX and TX data held in separate FIFOs\n   - 288 bytes for TX data, 256 bytes for RX data\n   - FIFOs loaded/unloaded via 32-bit TL-UL registers\n   - Support for arbitrary byte-count in each transaction\n   - Parametrizable support for Big- or Little-Endian systems in ordering I/O bytes within 32-bit words.\n- SPI clock rate controlled by separate input clock to core\n   - SPI SCK line typically toggles at 1/2 the core clock frequency\n   - An additional clock rate divider exists to reduce the frequency if needed\n- Support for all SPI polarity and phases (CPOL, CPHA)\n   - Additional support for \"Full-cycle\" SPI transactions, wherein data can be read a full SPI Clock cycle after the active edge (as opposed to one half cycle as is typical for SPI interfaces)\n- Single Transfer Rate (STR) only (i.e. data received on multiple lines, but only on one clock edge)\n   - *No support* for Dual Transfer Rate (DTR)\n- Pass-through mode for coordination with [SPI_DEVICE IP](../spi_device/README.md)\n- Automatic control of chip select lines\n- Condensed interrupt footprint: Two lines for two distinct interrupt classes: \"error\" and \"spi_event\"\n   - Fine-grain interrupt masking supplied by secondary enable registers\n\n## Description\n\nThe Serial Peripheral Interface (SPI) is a synchronous serial interface, commonly used for NOR flash devices and off-chip peripherals such as ADCs, DACs, or temperature sensors.\n\nThe interface is a *de facto* standard (not a formal one), so there is no definitive reference or established compliance criteria.\nIt is therefore important to consult the data sheets for the desired peripheral devices in order to ensure compatibility.\nThe OpenTitan SPI_HOST IP is primarily designed for controlling Quad SPI NOR flash devices, such as the [W25Q01JV Serial NOR flash from Winbond](https://www.winbond.com/resource-files/W25Q01JV%20SPI%20RevB%2011132019.pdf) or the [1 Gb M25QL NOR flash from Micron](https://media-www.micron.com/-/media/client/global/documents/products/data-sheet/nor-flash/serial-nor/mt25q/die-rev-b/mt25q_qlkt_l_01g_bbb_0.pdf?rev=43d124f03bbf4ef0962435e9ec63a185).\nThe implementation however is runtime-configurable to support a wide variety of devices, although the Winbond serial flash device is used as the primary reference for understanding our host requirements.\n\nThere are also a number of good references describing legacy host implementations for this protocol, which are useful for understanding some of the general needs for a wider range of target devices.\nFor instance, the legacy [SPI Block Guide](https://web.archive.org/web/20150413003534/http://www.ee.nmt.edu/~teare/ee308l/datasheets/S12SPIV3.pdf) from Motorola contains a definitive overview of some of the general requirements for a standard SPI host, notably the definitions of SPI clock phase and polarity (CPOL and CPHA).\n",
  "keymgr": "# Key Manager HWIP Technical Specification\n\n[`keymgr`](https://reports.opentitan.org/hw/ip/keymgr/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/keymgr/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/keymgr/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/keymgr/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/keymgr/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the OpenTitan key manager.\n\n## Features\n\n- One-way key and identity (working) state hidden from software.\n- Version controlled identity and key generation.\n- Key generation for both software consumption and hardware sideload.\n- Support for DICE open profile.\n\n\n## Description\n\nThe key manager implements the hardware component of the [identities and root keys](https://docs.opentitan.org/doc/security/specs/identities_and_root_keys/) strategy of OpenTitan.\n\nIt enables the system to shield critical assets from software directly and provides a simple model for software to use derived key and identity outputs.\n",
  "pattgen": "# Pattern Generator HWIP Technical Specification\n\n[`pattgen`](https://reports.opentitan.org/hw/ip/pattgen/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/pattgen/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pattgen/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pattgen/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pattgen/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the pattern generator hardware IP (HWIP).\nThis module conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top-level system.\n\n## Features\n\n- Generates time-dependent patterns on two (2) channels, each with its own clock.\n   - In each channel, data is transmitted serially on a one-bit data (`pda`) output, which is synchronous to a corresponding parallel clock signal (`pcl`).\n   - The channels can operate independently or synchronously with each other.\n- Each output channel supports the following configuration settings:\n    - Pattern data per output (up to 64 bits of data).\n    - 32-bit pre-divider to derive pattern clock from I/O clock (minimum ratio: 2).\n    - Each pattern can be repeated up to 1024 times.\n    - The polarity of the clock signal is programmable.\n- The block sends an interrupt on pattern completion.\n\n## Description\n\nThe pattern generator HWIP transmits short (maximum 64 bits) time-dependent data patterns on two clock-parallel channels.\nEach channel consists of one clock (`pcl`) and one data (`pda`) line.\nThe output channels may be activated and operated independently, or they can be started at the same time to effectively create a 4-output pattern.\n\n## Compatibility\n\nThis IP block does not have any direct hardware compatibility requirements.\n",
  "gpio": "# GPIO HWIP Technical Specification\n\n[`gpio`](https://reports.opentitan.org/hw/ip/gpio/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/gpio/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/gpio/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/gpio/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/gpio/code.svg)\n\n# Overview\n\nThis document specifies GPIO hardware IP functionality. This\nmodule conforms to the [Comportable guideline for peripheral device\nfunctionality](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader top\nlevel system.\n\n## Features\n\n- 32 GPIO ports\n- Configurable interrupt per GPIO for detecting rising edge, falling edge,\n  or active low/high input\n- Two ways to update GPIO output: direct-write and masked (thread-safe) update\n\n## Description\n\nThe GPIO block allows software to communicate through general purpose I/O\npins in a flexible manner. Each of 32 independent bits can be written\nas peripheral outputs in two modes. Each of the 32 bits can be read\nby software as peripheral inputs.  How these peripheral inputs and\noutputs are connected to the chip IO is not within the scope of this\ndocument. See the Comportability Specification for peripheral IO options\nat the top chip level.\n\nIn the output direction, this module provides direct 32b access to each\nGPIO value using direct write. This mode allows software to control all\nGPIO bits simultaneously. Alternately, this module provides masked writes\nto half of the bits at a time, allowing software to affect the output\nvalue of a subset of the bits without requiring a read-modify-write.\nIn this mode the user provides a mask of which of the 16 bits are to be\nmodified, along with their new value. The details of this mode are given\nin the [Programmers Guide](#programmers-guide) below.\n\nIn the input direction, software can read the contents of any of the GPIO\nperipheral inputs.  In addition, software can request the detection of an\ninterrupt event for any of the 32 bits in a configurable manner.  The choices\nare positive edge, negative edge or level detection events. A noise\nfilter is available through configuration for any of the 32 GPIO inputs.\nThis requires the input to be stable for 16 cycles of the\nmodule clock before the input register reflects the change and interrupt\ngeneration is evaluated. Note that if the filter is enabled and the pin\nis set to output then there will be a corresponding delay in a change\nin output value being reflected in the input register.\n\nSee the Design Details section for more details on output, input, and\ninterrupt control.\n",
  "rom_ctrl": "# ROM Controller Technical Specification\n\n[`rom_ctrl`](https://reports.opentitan.org/hw/ip/rom_ctrl/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/rom_ctrl/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rom_ctrl/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rom_ctrl/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rom_ctrl/code.svg)\n\n# Overview\n\nThis document describes the ROM controller (`rom_ctrl`).\nThis module attaches as a peripheral to the system bus, and thus follows the [Comportability Specification](../../../doc/contributing/hw/comportability/README.md).\n\nThe ROM controller interfaces between the system bus and the ROM.\nThis ROM has scrambled contents (scrambled with a fixed key, derived from a global constant).\nThe controller is responsible for descrambling these contents on memory fetches.\n\nUnlike the [SRAM controller](../sram_ctrl/README.md), which performs the equivalent task for SRAM, the ROM controller also contains a *ROM checker* block.\nThis ROM checker is used to compute a cryptographic hash of the ROM contents just after boot, detecting any malicious changes that have been made to the ROM when the system was at rest.\n\n## Features\n\n- Logic for memory and address descrambling\n- Post-boot ROM integrity check\n- Alert trigger and status CSRs for ROM integrity errors or FSM glitches.\n",
  "kmac": "# KMAC HWIP Technical Specification\n\n[`kmac/masked`](https://reports.opentitan.org/hw/ip/kmac_masked/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/kmac/masked/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/kmac/masked/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/kmac/masked/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/kmac/masked/code.svg)\n\n[`kmac/unmasked`](https://reports.opentitan.org/hw/ip/kmac_unmasked/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/kmac/unmasked/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/kmac/unmasked/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/kmac/unmasked/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/kmac/unmasked/code.svg)\n\n# Overview\n\nThis document specifies the Keccak Message Authentication Code (KMAC) and Secure Hashing Algorithm 3 (SHA3) hardware IP functionality.\nThis module conforms to the OpenTitan guideline for peripheral device functionality.\nSee that document for integration overview within the broader OpenTitan top level system.\n\n## Features\n\n- Support for SHA3-224, 256, 384, 512, SHAKE[128, 256] and cSHAKE[128, 256]\n- Support byte-granularity on input message\n- Support 128b, 192b, 256b, 384b, 512b of the secret key length in KMAC mode\n- Support arbitrary output length for SHAKE, cSHAKE, KMAC\n- Support customization input string S, and function-name N up to 36 bytes total\n- 64b x 10 depth Message FIFO\n- First-order masking of the Keccak core using domain-oriented masking (DOM) to deter side-channel analysis (SCA), can optionally be disabled using compile-time Verilog parameters (for more details see [Keccak Round below](doc/theory_of_operation.md#keccak-round))\n- 1600b of internal state (internally represented in two shares if masking is enabled)\n- Performance (at 100 MHz):\n  - SHA3-224: 2.93 B/cycle, 2.34 Gbit/s (masking disabled) - 1.19 B/cycle, 952 Mbit/s (DOM)\n  - SHA3-512: 1.47 B/cycle, 1.18 Gbit/s (masking disabled) - 0.59 B/cycle, 472 Mbit/s (DOM)\n\n## Description\n\nThe KMAC module is a Keccak based message authentication code generator to check the integrity of an incoming message and a signature signed with the same secret key.\nThe secret key length can vary up to 512 bits.\n\nThe KMAC generates at most 1600 bits of the digest value at a time which can be read from the STATE memory region.\nThere's a way for the software to read more digest values by manually running the Keccak rounds.\nThe details of the operation are described in the [SHA3 specification, FIPS 202](https://csrc.nist.gov/publications/detail/fips/202/final) known as _sponge construction_.\n\nThe KMAC HWIP also performs the SHA3 hash functions without the authentication, whose purpose is to check the correctness of the received message.\nThe KMAC IP supports various SHA3 hashing functions including SHA3 Extended Output Function (XOF) known as SHAKE functions.\n\nThe KMAC HWIP implements a defense mechanism to deter SCA attacks.\nIt is expected to protect against 1st-order SCA attacks by implementing masked storage and [Domain-Oriented Masking (DOM)](https://eprint.iacr.org/2017/395.pdf) inside the Keccak function.\n",
  "uart": "# UART HWIP Technical Specification\n\n[`uart`](https://reports.opentitan.org/hw/ip/uart/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/uart/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/uart/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/uart/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/uart/code.svg)\n\n# Overview\n\nThis document specifies UART hardware IP functionality. This module\nconforms to the\n[Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\nSee that document for integration overview within the broader\ntop level system.\n\n\n## Features\n\n- 2-pin full duplex external interface\n- 8-bit data word, optional even or odd parity bit per byte\n- 1 stop bit\n- 64 x 8b RX buffer\n- 32 x 8b TX buffer\n- Programmable baud rate\n- Interrupt for transmit empty, receive overflow, frame error, parity error, break error, receive\n  timeout\n\n## Description\n\nThe UART module is a serial-to-parallel receive (RX) and parallel-to-serial\n(TX) full duplex design intended to communicate to an outside device, typically\nfor basic terminal-style communication. It is programmed to run at a particular\nbaud rate and contains only a transmit and receive signal to the outside world,\ni.e. no synchronizing clock. The programmable baud rate guarantees to be met up\nto 1Mbps.\n\n## Compatibility\n\nThe OpenTitan UART is feature compatible to a specific implementation in [Chromium EC](https://chromium.googlesource.com/chromiumos/platform/ec/+/refs/heads/cr50_stab/chip/g/uart.c).\nAdditional features such as parity have been added.\n",
  "aes": "# AES HWIP Technical Specification\n\n[`aes/masked`](https://reports.opentitan.org/hw/ip/aes_masked/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/aes/masked/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aes/masked/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aes/masked/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aes/masked/code.svg)\n\n[`aes/unmasked`](https://reports.opentitan.org/hw/ip/aes_unmasked/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/aes/unmasked/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aes/unmasked/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aes/unmasked/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/aes/unmasked/code.svg)\n\n# Overview\n\nThis document specifies the AES hardware IP functionality.\n[Advanced Encryption Standard (AES)](https://www.nist.gov/publications/advanced-encryption-standard-aes) is the primary symmetric encryption and decryption mechanism used in OpenTitan protocols.\nThe AES unit is a cryptographic accelerator that accepts requests from the processor to encrypt or decrypt 16 byte blocks of data.\nIt is attached to the chip interconnect bus as a peripheral module and conforms to the [Comportable guideline for peripheral functionality.](../../../doc/contributing/hw/comportability/README.md)\n\n\n## Features\n\nThe AES unit supports the following features:\n\n- Encryption/Decryption using AES-128/192/256 in the following cipher block modes:\n  - Electronic Codebook (ECB) mode,\n  - Cipher Block Chaining (CBC) mode,\n  - Cipher Feedback (CFB) mode (fixed data segment size of 128 bits, i.e., CFB-128),\n  - Output Feedback (OFB) mode, and\n  - Counter (CTR) mode.\n- Support for AES-192 can be removed to save area, and is enabled/disabled using a compile-time Verilog parameter\n- First-order masking of the cipher core using domain-oriented masking (DOM) to deter side-channel analysis (SCA), can optionally be disabled using compile-time Verilog parameters (for more details see [Security Hardening](./doc/theory_of_operation.md#side-channel-analysis))\n- Latency per 16 byte data block of 12/14/16 clock cycles (unmasked implementation) and 56/66/72 clock cycles (DOM) in AES-128/192/256 mode\n- Automatic as well as software-initiated reseeding of internal pseudo-random number generators (PRNGs) with configurable reseeding rate resulting in max entropy consumption rates ranging from 343 Mbit/s to 0.042 Mbit/s (at 100 MHz).\n- Countermeasures for deterring fault injection (FI) on the control path (for more details see [Security Hardening](./doc/theory_of_operation.md#fault-injection))\n- Register-based data and control interface\n- System key-manager interface for optional key sideload to not expose key material to the processor and other hosts attached to the system bus interconnect.\n- On-the-fly round-key generation in parallel to the actual encryption/decryption from a single initial 128/192/256-bit key provided through the register interface (for more details see [Theory of Operations](./doc/theory_of_operation.md))\n\nThis AES unit targets medium performance (16 parallel S-Boxes, \\~1 cycle per round for the unmasked implementation, \\~5 cycles per round for the DOM implementation).\nHigh-speed, single-cycle operation for high-bandwidth data streaming is not required.\n\nCipher modes other than ECB, CBC, CFB, OFB and CTR are beyond this version of the AES unit but might be supported in future versions.\nGalois/Counter Mode (GCM) can be implemented by leveraging [Ibex](../rv_core_ibex/README.md) for the GHASH operation as demonstrated in [OpenTitan's library of cryptographic implementations](https://github.com/lowRISC/opentitan/tree/master/sw/device/lib/crypto).\n\n\n## Description\n\nThe AES unit is a cryptographic accelerator that accepts requests from the processor to encrypt or decrypt 16B blocks of data.\nIt supports AES-128/192/256 in Electronic Codebook (ECB) mode, Cipher Block Chaining (CBC) mode, Cipher Feedback (CFB) mode (fixed data segment size of 128 bits, i.e., CFB-128), Output Feedback (OFB) mode and Counter (CTR) mode.\nFor more information on these cipher modes, refer to [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\nGalois/Counter Mode (GCM) can be implemented using [Ibex](../rv_core_ibex/README.md) for the GHASH operation as demonstrated in the [OpenTitan Cryptography Library](../../../doc/security/cryptolib/README.md).\nTo improve the performance of GCM, instructions of the [RISC-V Bit-Manipulation Extension of Ibex](https://ibex-core.readthedocs.io/en/latest/03_reference/instruction_decode_execute.html#arithmetic-logic-unit-alu) can be leveraged.\nIn particular, carry-less multiply instructions can help to speed up the GHASH operation.\nFor details on GCM, refer to [Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf).\nOther cipher modes might be added in future versions.\n\nThe AES unit is attached to the chip interconnect bus as a peripheral module.\nCommunication with the processor happens through a set of control and status registers (CSRs).\nThis includes input/output data and key, as well as status and control information.\nIn addition, the AES unit includes a separate interface through which [Key Manager](../keymgr/README.md) can provide the key without exposing it to the processor or other hosts attached to the chip interconnect bus.\n",
  "top_earlgrey_pinmux": "No README available.",
  "top_earlgrey_sensor_ctrl": "# Sensor Control Technical Specification\n\n# Overview\n\nThis document specifies the functionality of the `sensor control` module.\nThe `sensor control` module is a comportable front-end to the [analog sensor top](../ast/README.md).\n\nIt provides basic alert functionality, pad debug hook ups, and a small amount of open source visible status readback.\nLong term, this is a module that can be absorbed directly into the `analog sensor top`.\n\n## Features\n\n- Alert hand-shake with `analog sensor top`\n- Alert forwarding to `alert handler`\n- Status readback for `analog sensor top`\n- Pad debug hook up for `analog sensor top`\n- Wakeup based on alert events\n",
  "top_earlgrey_xbar_peri": "No README available.",
  "top_earlgrey_ast": "# Analog Sensor Top Technical Specification\n\nAnalog Sensor Top, also known as the AST, is the OpenTitan analog and\nsecurity companion. Within the AST are various analog functions (such as\nclocks, regulators, random number generators) needed to make the device\nfunction, as well as physical security sensors necessary to protect the\ndevice from physical attacks or manipulation.\n\nAt a high level, AST communicates with a number of OpenTitan comportable\nmodules. See the diagram below for an overview.\n\n![Analog Sensor Top Diagram](./doc/top_diagram.png)\n\nIn the following sections, each family of connections is briefly\ndescribed and explained. Note, the analog connections to AST are not\nshown in the diagram, but will be explained as well.\n\n# Interface Signals Table\n\nSee the table [here](./doc/interfaces.md).\n\n# Interfaces Description Note\n\nThe information below augments the [Interface Signals Table](./doc/interfaces.md).\nFor further details, see the corresponding signals description in the\ntable.\n\n# Power Connectivity\n\nNote: Power signals may not appear in the verilog files, however, they\nare described for completeness.\n\n## External Supplies\n\nAST has four external power supplies VCC, AVCC, VIOA and VIOB. VCC is\nthe main supply, AVCC is an analog VCC supply. VIOA and VIOB are two\nadditional I/O supplies.\n\n## Core Supplies\n\nThe core supplies are generated from the VCC supply. There are two core\nsupply domains: VCMAIN and VCAON. VCAON, as its name implies, is the\nalways-on core supply used to power components that stay active during\ndevice low power states. VCMAIN on the other hand, powers most chip\nlogic such as RISC-V processor, crypto modules and almost all memories\nand peripherals. The VCMAIN supply can be turned off when requested,\nVCAON on the other hand, is active whenever VCC is active. AST core\nlogic is powered by VCAON.\n\n# Power Control and Reset\n\n## Core Power Control and Indication\n\nVCMAIN is the only supply that can be directly influenced by OpenTitan.\nThe power manager can request VCMAIN to shutdown through main_pd_ni. The\nstate of VCMAIN is reflected by the vcmain_pok_o signal.\n\n## IO Power Indication\n\nIO power state is reflected to OpenTitan by vioa_pok_o and viob_pok_o\nsignals\n\n## Main (VCC) Power Detection and Flash Protection\n\nOn VCC power-down detection, 'flash_power_ready_h_o', is\nimmediately negated. In addition, SYS clock, IO clock and USB clock are\nstopped. This means that negation of the VCC supply always triggers the\nflash brown-out (BOR) protection circuitry.\n\nWhen entering deep-sleep mode, 'flash_power_down_h_o' is\nasserted before negating VCMAIN until VCMAIN is back up.\n\n## Resets\n\nThe AST supports the generation of the root reset for the reset manager.\nIt is driven by 'vcaon_pok_o' which is generated inside AST.\nThe 'vcaon_pok_o' is activated when the following conditions\nare met: VCC is detected, internal voltage regulator is active and\n'por_ni' reset input is inactive. 'por_ni' is\ndriven by an external chip reset pin. The following table and diagrams\ndescribe the AST sub-modules resets.\n\n| **Components**                                   | **Reset by**             | **Comments**                                                                                                                             |\n|--------------------------------------------------|--------------------------|------------------------------------------------------------------------------------------------------------------------------------------|\n| Regulators, 'power-OK' logic and always-on clock | self-start / vcaon_pok_o | These circuits come to life shortly after VCC crosses its detection threshold. vcaon_pok_o serves as their register configuration reset. |\n| System/USB/IO clock generators                   | vcmain_pok_o             | vcmain_pok_o is also fed by vcaon_pok_o and por_ni.                                                                                      |\n| Interface functions                              | Input reset              | Per the corresponding interface [<u>clock domain reset input</u>](#clock-and-reset-inputs).                                              |\n\n# Clock Outputs\n\nAST generates four clocks: System clock, IO clock, USB clock and\nAlways-on clock. Most clocks have 'enable' inputs and a\ncorresponding 'valid' output. When the enable is\nde-asserted, the corresponding clock stops and valid is dropped to 0.\nWhen the enable is asserted, the clocks begin outputting in a\n'glitchless' manner and the valid is raised to 1. Unless\nnoted otherwise, clocks duty cycle is 50% +/-5%. At boot time, clocks\nstart toggling at a different (typically slower) frequency than their\ntarget. They are configured to their target frequency by the ROM code.\nOnce configured, their frequency is maintained within +/-3% of their\ntarget as long as the chip remains in its intended operating conditions\nuntil the next boot.\n\nThe OpenTitan power and clock managers are responsible for manipulating\nthe enables and observing the valids to know when clocks can be safely\nreleased to the system.\n\n## USB Clock Calibration\n\nThe USB clock requires an accuracy that cannot be achieved by the AST\nclocks natively. As a result, information from USB frames are used to\n[<u>calibrate the\nclock</u>](../../../ip/usbdev/README.md#clocking).\n\n# Clock and Reset Inputs\n\nThe root clocks and resets are generated inside AST. However, the clocks\ngo through gating and optional division in the OpenTitan top level and\npropagate back into AST as feedback clocks, each with associated\nsynchronized reset de-assertion to ensure it can synchronize with the\nvarious comportable modules. The input resets are used for the different\nAST interface functions. For further details about AST resets, see\n[<u>Resets</u>](#resets) section.\n\nNote: There are several reasons for routing leaf clocks back into AST\ninstead of using the root clocks directly\n\n- The leaf clocks may be divided down from the root clock and that\n frequency is used to drive the interface. For example,\n clk_src_io_clk_o is 96MHz, but comportable modules use either 48MHz\n or 24MHz.\n\n- The leaf clocks and root clocks have very different clock tree depths\n and may be difficult for timing closure if they interacted directly.\n\n- Decouple AST internal design from OpenTitan top-level interfaces clock\n and reset selection.\n\n# Register Access Interface\n\nAST registers can be accessed via TL-UL interface. These registers are\nused for test and calibration purposes and are not required for runtime\noperation. See the [<u>Interface Signals\nTable</u>](#interface-signals-table) for more details.\n\n## AST registers initialization during boot.\n\nIn PROD*/DEV Lifecycle states, the ROM code must copy all AST REGA\nregisters values from OTP to AST. During other Lifecycle states, the ROM\ncode may also copy all AST REGA registers. It is recommended for the\nROM code to condition the copy by a digest verification of the register\nvalues. If such a digest is too complicated, a simple tag can be used to\ncondition the copy instead. The AST register copy operation must be\nperformed in order and must include all REGA registers (starting from\nREGA0 and ending at the last REGA). AST sets the ast_init_done_o signal\nafter the copy completion.\n\nAfter the copy, ROM code can either poll for ast_init_done_o assertion\nwith 100 us timeout (in practice, it should take way less) or ignore it\nand let the next SW layers handle it. It is recommended to set an OTP\nfield for determining the ROM code action.\n\nThe boot code is expected to check all AST output alert signals before\nhanding over the control to the next code layer (ROM_EXT). The ROM code\nresponse per alert should be defined in a dedicated OTP space.\nRecommended response types (per alert):\n\n1.  Do nothing and don't clear the event\n\n2.  Do nothing (continue to the next SW layer) and clear the event\n\n3.  Log the event in some NV space and halt\n\n4.  Halt immediately\n\nNote that in TEST_UNLOCK*/RMA state, the booter should always act per\n#1 regardless of the OTP setting.\n\nIt is recommended to redundantly code the OTP fields that control the\nROM code branching and also to protect the branching code from fault\ninjection.\n\n# ADC\n\nAST contains an analog to digital converter that can be used to sample\nvarious input signals. For OpenTitan this will primarily be used for\n[<u>debug cable detection</u>](https://www.sparkfun.com/products/14746).\nTo activate the ADC, the corresponding [<u>comportable\nmodule</u>](../../../ip/adc_ctrl/README.md) must first\nactivate the ADC through 'adc_pd_i'. Once activated, it should select\nthe channel to sample. Channel transition from zero to non-zero value\nstarts the ADC conversion. The ADC output is synchronous to the ADC\ncontroller.\n\n## ADC Usage Flow\n\n1.  Activate the ADC by negating 'adc_pd_i'\n\n2.  Wait 30 uS for the ADC to wake up.\n\n3.  Select an analog channel to measure by setting the corresponding bit\n in 'adc_chnsel_i' bus. This triggers a measurement.\n\n4.  Wait until 'adc_d_val' is set and read the result via\n 'adc_d_o'\n\n5.  Clear 'adc_chnsel_i' bus to 0. Note that adc_chnsel must\n be cleared to 0 before a new channel is selected.\n\n6.  Repeat steps 3-5 if more channels or more measurements are required\n\n7.  Deactivate the ADC by setting 'adc_pd_i' to save power.\n\n```wavejson\n{ signal: [ {node: '.a..b........', phase:0.2},\n{name: 'adc_pd_i' , wave: '10|..|.....|....|..1'}, {name:\n'clk_ast_adc_i', wave: 'p.|..|.....|....|...'}, {name:\n'adc_chnsel_i' , wave: '0.|.3|..04.|....|0..'}, {name:\n'adc_d_val_o' , wave: '0.|..|.1.0.|.1..|.0.'}, {name: 'adc_d_o' ,\nwave: 'x.|..|.3.x.|.4..|.x.', data: ['ch0', 'ch1', 'ch1']}, ],\nedge: [ 'a<->b wakeup time', ] }\n```\n\n# Random Number Generator\n\nAST contains a random number generator that outputs random number\nbitstreams whenever it is enabled. After enabled by the [<u>comportable\ncontroller</u>](../../../ip/entropy_src/README.md)\nthrough 'rng_en_i', the AST begins generating multiple\nindependent four random bit streams. rng_b_o bit streams are valid and\ncan be sampled whenever 'rng_val_o' is asserted according to the\nfollowing diagram.\n\n```wavejson\n{signal: [ {name: 'clk' , wave:\n'p.|......|......|......'}, {name: 'rng_enable' , wave:\n'01|......|......|......'}, {name: 'rng_valid' , wave:\n'0.|..10..|..10..|..10..'}, {name: 'rng_b' , wave:\n'x.|..3...|..4...|..5.....', data: ['es0','es1','es2']}, ]}\n```\n\nThe expected rng_b_o valid output rate is about 50KHz. For more\ninformation on the RNG interface, please see the [<u>OpenTitan entropy\nsource module</u>](../../../ip/entropy_src/README.md).\n\n# Entropy Consumption\n\nAST consumes entropy for defensive purposes. However, AST does not\nconsume its raw entropy directly. Instead, AST receives entropy from the\n[<u>Entropy Distribution Network\n(EDN)</u>](../../../ip/edn/README.md). Note\nthat entropy_ack and entropy_i are packed into enropy_rsp_i in the\ninterface. Also note that once entropy_req_o is set, it will remain set\nuntil ack or until reset.\n\n```wavejson\n{signal: [\n\n{name: 'clk_ast_es_i' , wave: 'p.|..........'},\n\n{name: 'entropy_req_o' , wave: '01|.0.1.....0'},\n\n{name: 'entropy_ack_i' , wave: '0.|10.1.01..0'},\n\n{name: 'entropy_i' , wave: 'xx|2x.22x222x'},\n\n] }\n```\n\n# Countermeasures and Alerts\n\n## Alert Events\n\nAST's sensors and detectors, when triggered, output alert events\nto a sensor controller. The event signals are level until acknowledged\nby the controller. Further, the events are differentially encoded to\nensure they cannot be hard-wired or faulted to either '1' or\n'0'.\n\nInside the sensor controller, the events are then converted into alerts\nas part of the wider [<u>OpenTitan alert handling\nsystem</u>](../../ip_autogen/alert_handler/README.md).\n\n## Alert Signaling\n\nOutgoing alert events are level. Incoming event ack signals clear the\nalert event (similar to an interrupt). Outgoing alert events should be\nOR'd inside the sensor or power manager (depending on what level of deep\nsleep support is needed) to generate wakeup, that way AST does not need\nto do any additional handling for wakeups during low power mode.\n\nThe AST defines each alert signal in both positive (P) and negative (N)\npolarity (see ast_dif_t typedef with 'p' and 'n'\nsignals), however, the P and N signals are not necessarily fully\ndifferential, for example, at times, it might occur that both P and N\nare at the same value. For alert_o case, the correct way to treat it is\nto propagate an alert signal if either P is high or N is low.\n\n## Countermeasures\n\nMost countermeasure enablement is controlled by Nuvoton via the\nregisters interface. Clock jitter is an exception because there is a\nreasoning for dynamically turning it on and off (security/performance\ntradeoff). Unless stated otherwise, countermeasures are active in all\nmodes but deep-sleep.\n",
  "top_earlgrey_xbar_main": "No README available.",
  "top_earlgrey_rstmgr": "# Reset Manager HWIP Technical Specification\n\n[`rstmgr`](https://reports.opentitan.org/hw/top_earlgrey/ip_autogen/rstmgr/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr/code.svg)\n\n[`rstmgr_cnsty_chk`](https://reports.opentitan.org/hw/top_earlgrey/ip_autogen/rstmgr/dv/rstmgr_cnsty_chk/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr_cnsty_chk/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr_cnsty_chk/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr_cnsty_chk/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/rstmgr_cnsty_chk/code.svg)\n\n# Overview\n\nThis document describes the functionality of the reset controller and its interaction with the rest of the OpenTitan system.\n\n## Features\n\n*   Stretch incoming POR.\n*   Cascaded system resets.\n*   Peripheral system reset requests.\n*   RISC-V non-debug-module reset support.\n*   Limited and selective software controlled module reset.\n*   Always-on reset information register.\n*   Always-on alert crash dump register.\n*   Always-on CPU crash dump register.\n*   Reset consistency checks.\n",
  "top_earlgrey_flash_ctrl": "# Flash Controller HWIP Technical Specification\n\n[`flash_ctrl`](https://reports.opentitan.org/hw/top_earlgrey/ip_autogen/flash_ctrl/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/flash_ctrl/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/flash_ctrl/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/flash_ctrl/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/flash_ctrl/code.svg)\n\n# Overview\n\nThis document describes the flash controller functionality.\nThe flash controller is broken down into 3 major components\n* Open source flash controller\n* Closed source vendor flash wrapper\n* Closed source vendor flash module\n\nA breakdown of the 3 can be seen below\n![Flash High Level Boundaries](./doc/flash_boundaries.svg)\n\n\nThis open source flash controller is divided into two partitions.\n\n* Flash protocol controller\n* Flash physical controller\n\nThe remaining document focuses primarily on the function of these blocks.\n\nThis module conforms to the [Comportable guideline for peripheral functionality](https://opentitan.org/book/doc/contributing/hw/comportability).\nSee that document for integration overview within the broader top level system.\n\n## Features\n\n### Flash Protocol Controller Features\nThe flash protocol controller interfaces with software and other hardware components in the system (such as life cycle, key manager and OTP).\nRegardless of the flash size underneath, the flash controller maintains the same data resolution as the bus and processor (default 4B).\nThe flash physical controller (see section below) is then responsible for bridging that size gap between the default data resolution and the actual flash memory.\n\nThe protocol controller currently supports the following features:\n\n*  Controller initiated read, program and erase of flash.\n   *  Erase can be either of a page, or an entire bank.\n*  Support for differentiation between informational and data flash partitions.\n*  Support for accessing multiple types of information partition.\n   *  Some flash storage support multiple types of information storage for each information partition.\n*  Parameterized support for burst program / read, up to 64B.\n   *  Longer programs / reads are supported, however the protocol controller will directly back-pressure the bus if software supplies more data than can be consumed, or if software reads more than there is data available.\n   *  Software can also choose to operate by polling the current state of the FIFO or through FIFO interrupts (empty / full / level).\n*  Flash memory protection at page boundaries.\n*  Life cycle RMA entry.\n*  Key manager secret seeds that are inaccessible to software.\n*  Support vendor flash module [erase suspend](./doc/theory_of_operation.md#erase-suspend).\n*  Provisioning of flash specific attributes:\n   * High endurance.\n*  Idle indication to external power managers.\n*  Software control of flash code fetch.\n\n### Flash Physical Controller Features\n\nThe flash physical controller wraps the actual flash memory and translates both host and controller initiated requests into low level flash transactions.\n\nThe physical controller supports the following features\n*  Multiple banks of flash memory.\n*  For each flash bank, parameterized support for number of flash pages (default to 256).\n*  For each flash page, parameterized support for number of words and word size (default to 256 words of 8-bytes each).\n*  Data and informational partitions within each bank of flash memory.\n*  Arbitration between host requests and controller requests at the bank level.\n   *  Host requests are always favored, however the controller priority can escalate if it repeatedly loses arbitration.\n   *  Since banks are arbitrated independently and transactions may take different amounts of times to complete, the physical controller is also responsible for ensuring in-order response to both the controller and host.\n*  Flash read stage.\n   *  Each bank maintains a parameterizable number of read buffers in front of the flash memory (default to 4).\n   *  The read buffers behave as miniature read-only-caches to store flash data when flash words are greater than bus words.\n   *  When a program or erase collides with an entry already stored in the read buffer, the buffer contents are invalidated.\n      * This situation may arise if a read is followed by a program or erase.\n*  Flash program stage\n   *  Flash data word packing when flash word size is an integer multiple of bus word size.\n*  Flash scrambling\n   * Flash supports XEX scrambling using the PRINCE cipher.\n   * Scrambling is optional based on page boundaries and is configurable by software.\n*  Two types of Flash ECC support.\n   * A pre-scramble ICV (integrity check value) used for integrity verification implemented as ECC.\n   * A post-scramble ECC used for reliability detection, this is configurable on a page boundary.\n*  Life cycle modulated JTAG connection to the vendor flash module.\n\n\n### Flash Memory Overview\n\nUnlike sram, flash memory is not typically organized as a contiguous block of generic storage.\nInstead it is organized into data partitions and information partitions.\n\nThe data partition holds generic data like a generic memory would.\nThe information partition holds metadata about the data partition as well as design specific secret data.\nThis includes but is not limited to:\n*  Redundancy information.\n*  Manufacturer specific information.\n*  Manufacturer flash timing information.\n*  Design specific unique seeds.\n*  The redundancy pages themselves, which are not accessible directly as data partitions.\n\nNote, there **can** be more than one information partition, and none of them are required to be the same size as the data partition.\nSee the diagram below for an illustrative example.\n![Flash Example Partition](./doc/flash_partitions.svg)\n\nWhich type of partition is accessed is controlled through the [`CONTROL.PARTITION_SEL`](data/flash_ctrl.hjson#control) field.\nThe current flash controller implements one type of information partition and thus is controlled by 1 bit only.\nThis may change in the future.\n\nLastly, while the different partitions may be identical in some attributes, they are different in others.\n*  All types of partitions must have the same page size and word size; however they are not required to have the same number of pages, thus some partitions may be larger and others smaller.\n*  All types of partitions obey the same program and erase rules :\n   * A bit cannot be programmed back to 1 once it has been programmed to 0.\n   * Only erase can restore a bit to 1 under normal circumstances.\n*  All partitions (data and information) can be read, programmed and erased by the flash protocol controller, subject to [memory protection](./doc/theory_of_operation.md#memory-protection) and [life cycle qualification](./doc/theory_of_operation.md#memory-protection-for-key-manager-and-life-cycle) .\n*  System hosts (processor and other entities) can only directly read the data partition, they do not have any kind of access to information partitions.\n   * System hosts are also not subject to memory protection rules, as those apply to the flash protocol controller only.\n\nFor default assumptions of the design, see the [default configuration](./doc/theory_of_operation.md#flash-default-configuration).\n\n#### Addresses Map\n\n##### Bank Address\nThe flash address map is built upon the bank base address.\nThe bank size is based upon the number of pages in the data partition.\nThe first bank's address is always `0x0`.\nThe second bank's address is `0x0 + size_of_bank_in_bytes`.\n\nFor example:\nAssume each bank is 512KB in size.\nThe address of bank 0 is `0x0`.\nThe address of bank 1 is `0x80000`\n\n##### Page Address\nThe address of a particular page is calculated based on the page size and the index number of the page.\n\nFor example:\nAssume each page is 2KB in size.\n\nTo access page 0 in bank 1, the address would be the base address of bank 1 plus the base address of page 0.\nThis would still be `0x80000` in this case.\n\nTo access page 4 in bank 1, the address would then be `0x80000 + 2KB * 4 = 0x82000`.\n\n##### Partition Access\nAll partitions share the same addressing scheme.\nFor example, the page 0 address of any kind of partition is always the same.\n\nTo distinguish which partition is accessed, use the configuration in [`CONTROL.PARTITION_SEL`](data/flash_ctrl.hjson#control) and [`CONTROL.INFO_SEL`](data/flash_ctrl.hjson#control)\nNote however, the system host is only able to access the [data partitions](./doc/theory_of_operation.md#host-and-protocol-controller-handling).\n\n##### Default Address Map\nBased on the [default configuration](./doc/theory_of_operation.md#flash-default-configuration), the following would be the default address map for each partition / page.\n\nLocation        | Address      |\n----------------|------------- |\nBank 0 Page 0   | 0x0          |\nBank 0 Page 1   | 0x800        |\nBank 0 Page 2   | 0x1000       |\n...             | ...          |\nBank 0 Page 255 | 0x7F800      |\nBank 1 Page 0   | 0x80000      |\nBank 1 Page 1   | 0x80800      |\nBank 1 Page 2   | 0x81000      |\n...             | ...          |\nBank 1 Page 255 | 0xFF800      |\n\nNote when accessing from host, the system memory address for flash should be added to this offset.\n\n\n#### Secret Information Partitions\n\nTwo information partition pages (one for creator and one for owner) in the design hold secret seeds for the key manager.\nThese pages, when enabled by life cycle and OTP, are read upon flash controller initialization (no software configuration is required).\nThe read values are then fed to the key manager for later processing.\nThere is a page for creator and a page for the owner.\n\nThe seed pages can be programmed/erased/read by software when the following are set:\n* `lc_creator_seed_sw_rw_en` - allows software access to creator seed partition.\n* `lc_owner_seed_sw_rw_en` - allows software access to owner seed partition.\n\nThe seed pages are read under the following initialization conditions:\n*  life cycle sets provision enable - `lc_seed_hw_rd_en` is set.\n\nSee [life cycle](../../../ip/lc_ctrl/README.md#creator_seed_sw_rw_en-and-owner_seed_sw_rw_en) for more details on when this partition is allowed to be populated.\n\n#### Isolated Information Partitions\n\nOne information partition page in the design is used for manufacturing time authentication.\nThe accessibility of this page is controlled by life cycle and OTP.\n\nDuring TEST states, the isolated page is only programmable.\n* `lc_iso_part_sw_wr_en` is set, but `lc_iso_part_sw_rd_en` is not.\n\nDuring production and RMA states, the isolated page is also readable.\n* Both `lc_iso_part_sw_wr_en` and `lc_iso_part_sw_rd_en` are set.\n\nSee [life cycle](../../../ip/lc_ctrl/README.md#iso_part_sw_rd_en-and-iso_part_sw_wr_en) for more details\n",
  "top_earlgrey_pwrmgr": "# Power Manager HWIP Technical Specification\n[`pwrmgr`](https://reports.opentitan.org/hw/top_earlgrey/ip_autogen/pwrmgr/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/pwrmgr/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pwrmgr/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pwrmgr/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/pwrmgr/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the OpenTitan power manager.\n\n## Features\n\n- Cold boot, low power entry / exit and reset support.\n- 2 different low power modes.\n- Software initiated low power entry and hardware requested low power exit.\n- Peripheral reset requests\n- Low power abort and low power fall-through support.\n- ROM integrity check at power-up.\n- Local checks for escalator and power stability.\n\n## Description\n\nThe power manager sequences power, clocks, and reset resources of the design through cold boot, low power entry/exit and reset scenarios.\n\nCold boot, also known as POR (power on reset) is the first reset state of the design.\nThe power manager sequences the design from a freshly reset state to an active state where software can be initialized.\n\n- Low power entry is the process in which the device enters one of two low power modes (sleep or deep sleep).\n- Low power exit is the process in which the device exits low power mode and returns to active state.\n- Low power entry is always initiated by software, while low power exit is always initiated by a previously setup hardware event such as pins or internal timers.\n- The power manager processes the software and hardware requests to perform the appropriate actions.\n\nReset scenarios refer to non-POR events that cause the device to reboot.\nThere are various stimuli that can cause such a reset, ranging from external user input to watchdog timeout.\nThe power manager processes the reset request and brings the device to an appropriate state.\n",
  "top_earlgrey_rv_plic": "# Interrupt Controller Technical Specification\n\n# Overview\n\nThis document specifies the Interrupt Controller (RV_PLIC) functionality. This\nmodule conforms to the\n[Comportable guideline for peripheral functionality](../../../../doc/contributing/hw/comportability/README.md).\nSee that document for integration overview within the broader top level system.\n\n\n## Features\n\n- RISC-V Platform-Level Interrupt Controller (PLIC) compliant interrupt controller\n- Support arbitrary number of interrupt vectors (up to 255) and targets\n- Support interrupt enable, interrupt status registers\n- Memory-mapped MSIP register per HART for software interrupt control.\n\n## Description\n\nThe RV_PLIC module is designed to manage various interrupt sources from the\nperipherals. It receives interrupt events as either edge or level of the\nincoming interrupt signals (``intr_src_i``) and can notify multiple targets.\n\n## Compatibility\n\nThe RV_PLIC is compatible with any RISC-V core implementing the RISC-V privilege specification.\n",
  "top_earlgrey_alert_handler": "# Alert Handler Technical Specification\n\n[`alert_handler`](https://reports.opentitan.org/hw/top_earlgrey/ip_autogen/alert_handler/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/alert_handler/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/alert_handler/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/alert_handler/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/alert_handler/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the alert handler mechanism.\nThe alert handler is a module that is a peripheral on the chip interconnect bus, and thus follows the [Comportability Specification](../../../../doc/contributing/hw/comportability/README.md).\nIt gathers alerts - defined as interrupt-type signals from other peripherals that are designated as potential security threats - throughout the design, and converts them to interrupts that the processor can handle.\nIf the processor does not handle them, the alert handler mechanism provides hardware responses to handle the threat.\n\n\n## Features\n\n- Differentially-signaled, asynchronous alert inputs from `NAlerts` peripheral sources, where `NAlerts` is a function of the requirements of the peripherals.\n\n- Ping testing of alert sources:\n    - responder module requests periodic alert response from each source to ensure proper wiring.\n    - reset-asserted and clock-gated information is used to temporarily pause the ping mechanism on alert channels that are in a low-power state.\n\n- Register locking on all configuration registers.\n    - Once locked, can not be modified by software until next system reset.\n\n- Register-based assignment of alert to alert-class.\n    - Four classes, can be individually disabled.\n    - Each class generates one interrupt.\n    - Disambiguation history for software to determine which alert caused the class interrupt.\n    - Each class has configurable response time for escalation.\n    - Disable allows for ignoring alerts, should only be used in cases when alerts are faulty.\n      Undesirable access is enforced by locking the register state after initial configuration.\n\n- Register-based escalation controls.\n    - Number of alerts in class before escalation.\n    - Timeout for unhandled alert IRQs can also trigger escalation.\n    - Configurable escalation enables for 4 escalation signals.\n        - Could map to NMI, wipe secrets signal, lower privilege, chip reset, etc.\n        - Escalation signals differentially-signaled with heartbeat, will trigger response if differential or heartbeat failure at destination.\n    - Configurable time in cycles between each escalation level.\n\n- Two locally sourced hardware alerts.\n    - Differential signaling from a source has failed.\n    - Ping response from a source has failed.\n\n\n## Description\n\nThe alert handler module manages incoming alerts from throughout the system, classifies them, sends interrupts, and escalates interrupts to hardware responses if the processor does not respond to any interrupts.\nThe intention is for this module to be a stand-in for security responses in the case where the processor can not handle the security alerts.\n\nIt is first notable that all security alerts are rare events.\nModule and top level designers should only designate events as alerts if they are expected to never happen, and if they have potential security consequences.\nExamples are parity errors (which might indicate an attack), illegal actions on cryptography or security modules, physical sensors of environmental modification (e.g. voltage, temperature), etc.\nAlerts will be routed through this module and initially converted to interrupts for the processor to handle.\nThe expectation is that the secure operating system has a protocol for handling any such alert interrupt in software.\nThe operating system should respond, then clear the interrupt.\nSince these are possible security attacks, the response is not always obvious, but the response is beyond the scope of this document.\n\nThis module is designed to help the full chip respond to security threats in the case where the processor is not trusted: either it has been attacked, or is not responding.\nIt does this by escalating alerts beyond a processor interrupt.\nIt provides four such escalation signals that can be routed to chip functions for attack responses.\nThis could include such functions as wiping secret chip material, power down, reset, etc.\nIt is beyond the scope of this document to specify what those escalation responses are at the chip level.\n\nTo ease software management of alerts, classification is provided whereby each alert can be classified into one of four classes.\nHow the classification is done by software is beyond the scope of this document, but it is suggested that alerts of a similar profile (risk of occurring, level of security concern, frequency of false trigger, etc) are classed together.\nFor each class a counter of alerts is kept, clearable by software.\nIf that counter exceeds a programmable maximum value, then the escalation protocol for that class begins.\n\nThe details for alert signaling, classification, and escalation are all given in the Theory of Operations section.\n",
  "top_earlgrey_clkmgr": "# Clock Manager HWIP Technical Specification\n\n[`clkmgr`](https://reports.opentitan.org/hw/top_earlgrey/ip_autogen/clkmgr/dv/latest/report.html):\n![](https://dashboards.lowrisc.org/badges/dv/clkmgr/test.svg)\n![](https://dashboards.lowrisc.org/badges/dv/clkmgr/passing.svg)\n![](https://dashboards.lowrisc.org/badges/dv/clkmgr/functional.svg)\n![](https://dashboards.lowrisc.org/badges/dv/clkmgr/code.svg)\n\n# Overview\n\nThis document specifies the functionality of the OpenTitan clock manager.\n\n## Features\n\n- Attribute based controls of OpenTitan clocks.\n- Minimal software clock controls to reduce risks in clock manipulation.\n- External clock switch support\n- Clock frequency /time-out measurement\n",
  "lowrisc_ibex": "No README available.",
  "top_earlgrey": "# Top Earlgrey\n\n## Specification\n\nThe datasheet and specification of Earlgrey is located [here](./doc/datasheet.md).\n\n## Tool: TopGen\n\nTop Earlgrey is being generated by the integration tool, topgen\n(`util/topgen.py`). Please do not revise `rtl/top_earlgrey.sv`, the crossbar\nmodules, and the interrupt controller directly. Those files are auto-generated\nand sit in the repository for browsing purpose.\n\n### How to create top module\n\nTop module `rtl/top_earlgrey.sv` is created by `topgen.py`. Current top module\nis created with below command (assuming your current working directory is this\ndirectory):\n\n```console\n../../util/topgen.py -t data/top_earlgrey.hjson -o . -v\n```\n\nIt generates files below:\n\n- `rtl/top_earlgrey.sv`: Top module generated from the template\n    `data/top_earlgrey.sv.tpl` with the configuration file\n    `data/top_earlgrey.hjson`\n- `rtl/xbar_main.sv` and `rtl/tl_main_pkg.sv`: Crossbar module. As of now,\n    earlgrey has only one main crossbar. tlgen library is used to generate\n    these files.\n- `rtl/rv_plic*.sv` and `data/rv_plic.hjson`: Interrupt controller module.\n    `hw/ip/rv_plic/util/reg_rv_plic.py` tool is used to create RV_PLIC having\n    the number of interrupts specified in the hjson.\n\n### Adding new blocks into top level\nModify `data/top_earlgrey.hjson` to include new module\n- If new block has interrupts, also add to the `interrupt_module` definition\n\nModify `xbar_main.hjson` for the host / device connectivity\n\n### Modify configurations\n\nMain configuration for Top Earlgrey is in `data/top_earlgrey.hjson`. The users\nneed to specify the list of peripherals, memories, crossbars, and the interrupts\nin the configuration file. The tool then reads relevant information from the\neach peripheral blocks' configuration. For instance, if `uart` module is used,\nthe tool reads `hw/ip/uart/data/uart{_reg}.hjson` and parses the information such\nas input/output, the size of its register space, and interrupts.\n\nFor the memories, the tool utilizes the `type` and instantiates relevant modules\nincluding the converter from TL-UL interface to the native interfaces (SRAM,\nROM, eFlash). The user only needs to describe the base address and the memory\nsize.\n\nThe crossbar should be defined in the separate file. Please take a look at\n`data/xbar_main.hjson` as an example. In the top configuration, it needs to\ndefine the xbar and the clock, then the tool calls tlgen library to create the\ncrossbar design. Please remind that the instance name in the crossbar and that\nin the module field should be matched for topgen to create fields that tlgen\nuses.\n\n### Modify the template\n\nMain top template file is `data/top_earlgrey.sv.tpl`. In most cases, it isn't\nrequire to modify the template file. For instance, to add new IP into the top,\nthe user just needs to add the IP to the `module` field and revise the crossbar\nconnections in the crossbar configuration.\n\nThere might be some cases that needs to revise the template. As of now, a few\nmodules are hard-coded such as RISC-V core and the debug module. If any of these\nmodules need to be revised or some new modules not matching to the\ncomportability spec, it needs to be manually instantiated in the template file.\n"
}