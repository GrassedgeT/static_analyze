[
    {
      "description": "The module uses configuration inputs such as `digest_size_i` and `key_length_i` directly in combinatorial logic for critical operations like key padding and data path selection. These configurations are not latched at the beginning of an operation. If these signals are changed mid-operation (e.g., through a register write that bypasses software locks via a fault attack), the core's behavior will change immediately, leading to data corruption, incorrect digest calculation, or a denial of service.",
      "location": "hmac_core.sv:130-232",
      "code_snippet": "\n// key_length_i and digest_size_i are used directly in combinatorial blocks.\n// Example 1: Key padding logic\nalways_comb begin : adjust_key_pad_length\n  ...\n  unique case (key_length_i)\n    Key_512: begin\n      i_pad_256 = secret_key_i[1023:512] ^ {(BlockSizeSHA256/8){8'h36}};\n      ...\n    end\n  endcase\nend\n\n// Example 2: Data path mux\nassign sha_rdata_o =\n  ...\n  (sel_rdata == SelIPad && digest_size_i == SHA2_256)\n                ? '{data: i_pad_256[(BlockSizeSHA256-1)-32*pad_index_256-:32], mask: '1} :\n  (sel_rdata == SelIPad && ((digest_size_i == SHA2_384) || (digest_size_i == SHA2_512)))\n                ? '{data: i_pad_512[(BlockSizeSHA512-1)-32*pad_index_512-:32], mask: '1} :\n  ...\n      ",
      "impact": "An attacker who can modify configuration registers mid-operation can corrupt the HMAC computation. This could be used to bypass integrity checks if the resulting digest is predictable, or cause a denial of service. This violates the principle of predictable execution under fault conditions.",
      "trigger_condition": "An attacker performs a register write to change configuration (e.g., `CFG.digest_size`) while the HMAC core is actively processing data (i.e., not in the `StIdle` state). This could be achieved by bypassing higher-level software locks through fault injection or a race condition.",
      "recommendations": "The `hmac_core` module should latch the configuration inputs (`hmac_en_i`, `digest_size_i`, `key_length_i`) into internal registers upon receiving a `reg_hash_start_i` or `reg_hash_continue_i` command. All internal logic must then use these latched values for the entire duration of the operation, ensuring that the execution context is stable and immune to external configuration changes."
    },
    {
      "description": "The main state machine's `case` statement has a `default` branch that unconditionally transitions the FSM to the `StIdle` state. While this prevents a state machine lockup, it is an insecure failure mode. It does not assert any error signals, clear intermediate data structures, or notify the host system of the failure. This can lead to silent failures where an operation is aborted without the software being aware.",
      "location": "hmac_core.sv:449-451",
      "code_snippet": "\n      default: begin\n        st_d = StIdle;\n      end\n",
      "impact": "If a fault injection attack (e.g., clock glitch, SEU) forces the FSM into an illegal state, the module will silently return to idle. The software will not receive a `hmac_done` or `hmac_err` interrupt and may hang, waiting for an operation that will never complete. This can lead to a denial of service or, if a subsequent operation is started, potential data corruption from uncleared intermediate state.",
      "trigger_condition": "A fault injection attack or other hardware error forces the state register `st_q` to an unencoded or otherwise invalid value, causing the `default` case in the state transition logic to be taken.",
      "recommendations": "The `default` case should not silently transition to idle. It should transition to a dedicated, secure error state. This error state must trigger a fatal alert, clear all sensitive internal states (e.g., counters, FIFOs), and assert an error interrupt to reliably inform the software about the fault. This ensures a fail-safe and observable response to illegal state transitions."
    },
    {
      "description": "The `idle_o` status signal is assigned combinatorially from `idle_d`, which in turn depends directly on inputs like `reg_hash_start_i`. This creates a potential race condition where software reads the `idle` status as true, issues a start command, but the hardware state changes before the command is processed, causing the command to be dropped or mis-handled.",
      "location": "hmac_core.sv:471-482",
      "code_snippet": "\n  assign idle_d =\n      // .. is not idle when told to start or continue\n      (reg_hash_start_i || reg_hash_continue_i) ? 1'b0 :\n      // .. is idle when the FSM is in the Idle state\n      (st_q == StIdle) ? 1'b1 :\n      // .. is idle when it has processed a complete block of a message and is told to stop in any\n      // FSM state\n      (txcnt_eq_blksz && reg_hash_stop_d) ? 1'b1 :\n      // .. and keeps the current idle state in all other cases.\n      idle_q;\n\n  assign idle_o = idle_d;\n",
      "impact": "This race condition can lead to a desynchronization between the software driver and the hardware state. Software may believe an operation has started when it has been ignored by the hardware, leading to application-level timeouts, incorrect sequencing of operations, or a denial of service.",
      "trigger_condition": "The vulnerability is triggered by the inherent delay between a software read of the status register (which reflects `idle_o`) and a subsequent write to the command register (which sets `reg_hash_start_i`). If the hardware state changes within this read-write window, the basis for the software's action becomes invalid.",
      "recommendations": "The `idle_o` output should be driven by the registered signal `idle_q` instead of the combinatorial signal `idle_d`. Change the assignment `assign idle_o = idle_d;` to `assign idle_o = idle_q;`. This ensures the status signal provided to the rest of the system is stable, synchronized to the clock, and accurately reflects the state of the module at the beginning of the clock cycle, preventing race conditions."
    },
    {
      "description": "The `txcount` register, which tracks the number of bytes processed, is incremented by manipulating a slice of the register (`txcount_d[63:5] = txcount[63:5] + 1'b1;`) instead of using a standard addition. This assumes the lower 5 bits are always zero. If a fault injection attack flips a bit in the lower part of the counter, it will not be corrected and will cause all subsequent length and block boundary calculations to be incorrect.",
      "location": "hmac_core.sv:265-267",
      "code_snippet": "\n    end else if (inc_txcount) begin\n      txcount_d[63:5] = txcount[63:5] + 1'b1; // increment by 32 (data word size)\n    end\n",
      "impact": "An incorrect `txcount` value can cause the state machine to misjudge the end of a message or the boundary of a hash block. This will lead to incorrect digest computation, which compromises the integrity guarantee of the HMAC. It could also cause the module to enter a deadlock state if it waits for a `txcnt_eq_blksz` condition that never becomes true, resulting in a denial of service.",
      "trigger_condition": "A fault injection attack (e.g., a bit-flip induced by voltage glitching or radiation) targets the `txcount` register, setting one of its lower 5 bits (`txcount[4:0]`) to a non-zero value.",
      "recommendations": "The counter increment logic should be made robust by using a standard full-width addition. Replace the sliced increment `txcount_d[63:5] = txcount[63:5] + 1'b1;` with a standard addition `txcount_d = txcount + 64'd32;`. This ensures the counter increments correctly even if its state is corrupted, making the design more resilient to faults."
    }
]
