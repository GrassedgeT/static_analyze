[
  {
    "Security feature bypassed": "Hardware Confidentiality and Asset Protection",
    "Finding": "The register top module for the HMAC peripheral contains a critical information disclosure vulnerability. The read multiplexer logic incorrectly exposes secret key material on the read data bus. Specifically, a read operation to the `WIPE_SECRET` register at offset `0x20` returns the first 32-bit word of the secret key (`key[0]`), and a read to the `KEY_0` register at offset `0x24` returns the second 32-bit word (`key[1]`). These registers are intended to be write-only to protect the confidentiality of the key.",
    "Location or code reference": "hmac_reg_top.sv:2412-2418",
    "Detection method": "Automate tools",
    "Security impact": "This vulnerability leads to a complete compromise of the HMAC peripheral's security. An attacker with standard register read access can trivially extract the first 64 bits of the secret key. This knowledge allows the attacker to forge valid Message Authentication Codes (MACs) for any message, thereby defeating the integrity and authenticity guarantees the HMAC is designed to provide.",
    "Adversary profile": "Privileged software in supervisor mode",
    "Proposed mitigation": "The read multiplexer logic in the `always_comb` block must be corrected. For read accesses to write-only registers, particularly `WIPE_SECRET` and the entire `KEY` register bank, the logic should be modified to return a constant, non-sensitive value, such as `32'h00000000`. This ensures that no part of the secret key can ever be read back over the bus.",
    "CVSSv3.1 Base score and severity": "High (8.8)",
    "CVSSv3.1 details": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N\nAttack Vector (AV): Local. The attacker requires local code execution to issue read commands to the peripheral's memory-mapped registers.\nAttack Complexity (AC): Low. The vulnerability is exploited by a simple read operation to a known address. No complex interaction or timing is required.\nPrivileges Required (PR): Low. The attack can be performed by any process that has memory-mapped access to the HMAC peripheral, which typically requires low-level (e.g., kernel/supervisor) but not necessarily administrative privileges.\nUser Interaction (UI): None. No user action is needed to trigger the exploit.\nScope (S): Unchanged. The exploit compromises the HMAC peripheral but does not grant the attacker control over a separate security authority or component.\nConfidentiality (C): High. The core secret asset of the component, the cryptographic key, is directly exposed, leading to a total loss of confidentiality.\nIntegrity (I): High. With the disclosed key, an attacker can forge authentication tags for any message, causing a total loss of data integrity protection.\nAvailability (A): None. The information disclosure does not, in itself, affect the operational availability of the HMAC peripheral or the system."
  },
  {
    "Security feature bypassed": "Secret Key Confidentiality",
    "Finding": "The read data multiplexer for the HMAC register file, implemented as a 'unique case' statement, has a flawed default behavior. When a read operation targets an unmapped address within the HMAC peripheral's address space, the default case is triggered. Instead of returning a safe, non-sensitive value, it is hardcoded to return the third 32-bit word of the secret key (`reg2hw.key[2].q`). This creates a direct hardware-level information disclosure vulnerability.",
    "Location or code reference": "hmac_reg_top.sv:2616-2618",
    "Detection method": "Automate tools",
    "Security impact": "An attacker with read access to the HMAC peripheral's register space can intentionally read from an unmapped address to exfiltrate 32 bits of the secret key. This significantly reduces the cryptographic strength of the HMAC function and the effort required for a full key recovery, compromising any security protocol that relies on this HMAC instance for authentication or integrity.",
    "Adversary profile": "Privileged software in supervisor mode",
    "Proposed mitigation": "The default case in the read multiplexer logic (lines 2616-2618) must be modified. It should be changed to return a fixed, non-sensitive value, such as `32'h0` or `32'hDEADBEEF`. This ensures that reads to unmapped or reserved addresses do not leak secret information and instead result in a predictable, safe value. Additionally, an error should be signaled back to the bus for such accesses.",
    "CVSSv3.1 Base score and severity": "4.4 (Medium)",
    "CVSSv3.1 details": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N\nAttack Vector: Local (L). The attacker must have local bus access to the HMAC peripheral's memory-mapped registers. This cannot be exploited remotely over a network.\nAttack Complexity: Low (L). Exploitation is straightforward. It only requires a single read operation to a known unmapped address within the HMAC address space. No complex interaction or race conditions are involved.\nPrivileges Required: High (H). The attacker must possess privileges that provide significant control over the vulnerable component, such as supervisor or machine-mode execution, to perform memory-mapped I/O reads to the peripheral's address space.\nUser Interaction: None (N). The vulnerability can be exploited without any action from a human user.\nScope: Unchanged (U). The exploit impacts the HMAC peripheral by disclosing its secret key. It does not provide the attacker with the ability to pivot and compromise other security domains or components. The scope of the impact is confined to the vulnerable component's security authority.\nConfidentiality: High (H). There is a total loss of confidentiality of a 32-bit portion of the secret key. This significantly undermines the security of the entire HMAC key and the cryptographic operations that depend on it.\nIntegrity: None (N). The vulnerability is read-only and does not allow the attacker to modify the key, the digest, or any other data.\nAvailability: None (N). The HMAC peripheral continues to function normally; there is no denial of service."
  },
  {
    "Security feature bypassed": "Register Access Control",
    "Finding": "The `reg_busy` signal in `hmac_reg_top.sv` is permanently hardcoded to zero (`1'b0`). This signal is intended to block bus access to the HMAC registers while a cryptographic operation is in progress. Because `reg_busy` is always inactive, the `tlul_adapter_reg` bus interface never stalls transactions, allowing an attacker to read the `DIGEST` registers at any time. This creates a race condition where an attacker can start an HMAC operation and read the intermediate digest value (the result of H(key XOR ipad || message)) before the final hash is computed. This leakage of an intermediate cryptographic state is a known attack vector against HMAC that can significantly aid in key-recovery attacks.",
    "Location or code reference": "hmac_reg_top.sv:2623-2627",
    "Detection method": "Automate tools",
    "Security impact": "Leakage of the intermediate HMAC digest violates the security assumptions of the HMAC algorithm (RFC 2104). This information can significantly reduce the complexity of brute-force or other analytical attacks to discover the secret key, especially if the attacker can control parts of the message. A successful exploit leads to a total compromise of the secret key, allowing an attacker to forge authentication tags for any message, thereby defeating the purpose of the HMAC peripheral.",
    "Adversary profile": "Unprivileged software at user-level mode",
    "Proposed mitigation": "The `reg_busy` signal must be connected to a status signal from the HMAC core that indicates when an operation is active. For example, it could be connected to the inverse of the core's idle status signal (e.g., `~hw2reg.status.hmac_idle.d`). This will ensure the `tlul_adapter_reg` correctly stalls any bus read/write attempts to the `DIGEST` registers until the HMAC operation is fully complete, preventing the leakage of any intermediate state.",
    "CVSSv3.1 Base score and severity": "Critical (9.6)",
    "CVSSv3.1 details": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N\nAttack Vector: Local (L). The attacker must have local software execution capabilities to interact with the memory-mapped registers of the HMAC peripheral.\nAttack Complexity: Low (L). The attack is simple to execute, requiring only a register write to start the operation followed by a register read to leak the state.\nPrivileges Required: Low (L). The attacker requires privileges to access the device's memory-mapped I/O, which is a common capability for user-level applications on many embedded systems.\nUser Interaction: None (N). The vulnerability can be exploited by malicious software without any human interaction.\nScope: Changed (C). A successful exploit leaks the secret HMAC key. This key is a security asset whose compromise can impact components beyond its own security scope, such as by allowing the attacker to forge authenticated firmware updates.\nConfidentiality: High (H). The vulnerability allows the recovery of the secret key, resulting in a total loss of confidentiality for that key.\nIntegrity: High (H). With the secret key, an attacker can forge valid HMAC tags for any message, leading to a total loss of data integrity for any system relying on this HMAC instance for authentication.\nAvailability: None (N). The exploit does not directly impact the availability of the HMAC peripheral or the system."
  },
  {
    "Security feature bypassed": "Secure Key Sanitization",
    "Finding": "The `WIPE_SECRET` register, a critical security feature designed to securely clear sensitive key material from the HMAC peripheral, is implemented with flawed access control logic. The write-enable signal for this register, `wipe_secret_we`, is incorrectly gated with the `reg_error` signal. As a result, the key wipe operation can only be triggered when a bus transaction error occurs simultaneously with a write to the `WIPE_SECRET` address. This prevents legitimate, error-free software from ever wiping the key, while creating a side-channel for an attacker to force a key wipe by intentionally causing a bus error.",
    "Location or code reference": "hmac_reg_top.sv:2122",
    "Detection method": "Automated tools",
    "Security impact": "The vulnerability has a dual impact. Firstly, it causes the failure of a critical security feature, as the intended key sanitization mechanism is non-functional under normal operating conditions, potentially leaving secret keys exposed in hardware longer than necessary. Secondly, it introduces a Denial of Service (DoS) vector. A privileged attacker can exploit the flawed logic to trigger an unintended key wipe by manipulating bus transactions to cause an error. This action disables the HMAC peripheral, denying service to any system component that relies on it for cryptographic functions.",
    "Adversary profile": "Privileged software in supervisor mode",
    "Proposed mitigation": "The logic for the `wipe_secret_we` signal must be corrected to remove the dependency on `reg_error`. The write enable should be gated with `!reg_error` to be consistent with other registers in the design. The vulnerable line of code should be changed from `assign wipe_secret_we = addr_hit[8] & reg_we & reg_error;` to `assign wipe_secret_we = addr_hit[8] & reg_we & !reg_error;`. This change ensures that the key wipe command only executes on a valid, error-free bus transaction as intended.",
    "CVSSv3.1 Base score and severity": "Medium (6.0)",
    "CVSSv3.1 details": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H\nAttack Vector (AV): Local. The attacker must execute privileged software on the target system.\nAttack Complexity (AC): Low. For an attacker with the required privileges, crafting a bus transaction that generates a protocol error is not complex.\nPrivileges Required (PR): High. The attack requires supervisor/kernel-level privileges to directly control memory-mapped I/O and generate a malformed bus transaction.\nUser Interaction (UI): None. The vulnerability is exploited by software without any human interaction.\nScope (S): Unchanged. The exploit affects the availability and integrity of the HMAC component but does not grant the attacker control over a different security authority.\nConfidentiality (C): None. The direct result of the exploit is a denial of service, not a disclosure of information.\nIntegrity (I): High. A fundamental security mechanism (key sanitization) is completely non-functional for its intended purpose, which constitutes a total loss of integrity for that security feature.\nAvailability (A): High. The attacker can render a critical cryptographic peripheral, the HMAC engine, unusable at will, causing a denial of service for any dependent system functions."
  },
  {
    "Security feature bypassed": "Register Access Control",
    "Finding": "The register top module `hmac_reg_top` implements inconsistent and functionally incorrect read logic for its write-only (WO) secret key registers. When a read operation is performed on key registers `HMAC_KEY_1` through `HMAC_KEY_31`, the hardware returns a hardcoded value of `32'h0` instead of generating a bus error or following a consistent, architecturally defined behavior for illegal reads. This behavior, found in the read-data multiplexer logic from lines 2420-2542, appears to be a code generation artifact and points to systemic weaknesses in the register file's implementation.",
    "Location or code reference": "hmac_reg_top.sv:2420-2542",
    "Detection method": "Automate tools",
    "Security impact": "The vulnerability has a low direct impact as it does not leak the secret key material. However, it represents a deviation from security design principles. By failing to generate an error on an illegal read of a write-only register, the hardware does not alert software to the invalid operation. This could allow an attacker to probe the register map without detection, and it demonstrates an unpredictable implementation of security-critical controls, which can undermine trust in the overall security of the device.",
    "Adversary profile": "Privileged software in supervisor mode",
    "Proposed mitigation": "The read logic for all write-only registers, including the entire key space (`KEY_0` through `KEY_31`), must be made consistent and secure. The recommended mitigation is to modify the register access logic to generate a bus error response for any read attempt to a write-only address. This ensures that illegal software operations are immediately flagged. If generating a bus error is not feasible, all write-only registers should consistently return a fixed, non-sensitive value (e.g., all zeros or all ones) upon a read, and this behavior must be clearly documented.",
    "CVSSv3.1 Base score and severity": "Low (2.0)",
    "CVSSv3.1 details": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:N\nAttack Vector: Local. The attacker must execute code on the system to perform the MMIO read.\nAttack Complexity: Low. A simple read to a specific register address is sufficient.\nPrivileges Required: High. The attack requires kernel or supervisor-level privileges to directly access memory-mapped hardware registers.\nUser Interaction: None. The attack is performed by software without any user involvement.\nScope: Unchanged. The vulnerability is contained within the HMAC peripheral and does not allow an attacker to affect other components or security domains.\nConfidentiality: None. No confidential data is exposed. The read returns a fixed value of zero.\nIntegrity: Low. The system fails to enforce the write-only nature of the register, allowing an illegal operation to proceed without an error. This represents a minor bypass of access control policy, which constitutes a low integrity impact.\nAvailability: None. The component remains fully available after the read operation."
  }
]